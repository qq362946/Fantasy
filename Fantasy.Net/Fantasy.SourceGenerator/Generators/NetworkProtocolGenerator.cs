using System.Linq;
using System.Text;
using Fantasy.SourceGenerator.Common;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
#pragma warning disable CS0649 // Field is never assigned to, and will always have its default value
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.

namespace Fantasy.SourceGenerator.Generators;
[Generator]
internal partial class NetworkProtocolGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var networkProtocols = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsNetworkProtocolClass(node),
                transform: static (ctx, _) => GetNetworkProtocolInfo(ctx))
            .Where(static info => info != null)
            .Collect();
       
        var compilationAndTypes = context.CompilationProvider.Combine(networkProtocols);
       
        context.RegisterSourceOutput(compilationAndTypes, static (spc, source) =>
        {
            if (CompilationHelper.IsSourceGeneratorDisabled(source.Left))
            {
                return;
            }

            if (!CompilationHelper.HasFantasyDefine(source.Left))
            {
                return;
            }

            if (source.Left.GetTypeByMetadataName("Fantasy.Assembly.INetworkProtocolRegistrar") == null)
            {
                return;
            }

            GenerateCode(spc, source.Left, source.Right!);
        });
    }

    #region GenerateCode

    private static void GenerateCode(
        SourceProductionContext context,
        Compilation compilation,
        IEnumerable<NetworkProtocolTypeInfo> networkProtocolTypeInfos)
    {
        var networkProtocolTypeInfoList = networkProtocolTypeInfos.ToList();
        // 获取当前程序集名称（仅用于注释）
        var assemblyName = compilation.AssemblyName ?? "Unknown";
        // 生成网络网络协议类型注册的类。
        GenerateNetworkProtocolTypesCode(context, assemblyName, networkProtocolTypeInfoList);
        // 生成OpCode注册方法。
        GenerateOpCodeRegistrarCode(context, assemblyName, networkProtocolTypeInfoList);
        // 生成Request消息的ResponseType辅助方法。
        GenerateResponseTypeRegistrarCode(context, assemblyName, networkProtocolTypeInfoList);
    }
    
    private static void GenerateNetworkProtocolTypesCode(
        SourceProductionContext context,
        string assemblyName, 
        List<NetworkProtocolTypeInfo> networkProtocolTypeInfoList)
    {
        var builder = new SourceCodeBuilder();
        // 添加文件头
        builder.AppendLine(GeneratorConstants.AutoGeneratedHeader);
        // 添加 using
        builder.AddUsings(
            "System",
            "System.Collections.Generic",
            "Fantasy.Assembly",
            "Fantasy.DataStructure.Collection"
        );
        // 开始命名空间（固定使用 Fantasy.Generated）
        builder.BeginNamespace("Fantasy.Generated");
        // 开始类定义（实现 IEventSystemRegistrar 接口）
        builder.AddXmlComment($"Auto-generated NetworkProtocol registration class for {assemblyName}");
        builder.BeginClass("NetworkProtocolRegistrar", "internal sealed", "INetworkProtocolRegistrar");
        builder.BeginMethod("public List<Type> GetNetworkProtocolTypes()");
        try
        {
            if (networkProtocolTypeInfoList.Any())
            {
                builder.AppendLine($"return new List<Type>({networkProtocolTypeInfoList.Count})");
                builder.AppendLine("{");
                builder.Indent();
                foreach (var system in networkProtocolTypeInfoList)
                {
                    builder.AppendLine($"typeof({system.FullName}),");
                }
                builder.Unindent();
                builder.AppendLine("};");
                builder.AppendLine();
            }
            else
            {
                builder.AppendLine($"return new List<Type>();");
            }
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            throw;
        }
        builder.EndMethod();
        builder.AppendLine();
        // 结束类和命名空间
        builder.EndClass();
        builder.EndNamespace();
        // 输出源代码
        context.AddSource("NetworkProtocolRegistrar.g.cs", builder.ToString());
    }
    
    private static void GenerateOpCodeRegistrarCode(
        SourceProductionContext context,
        string assemblyName, 
        List<NetworkProtocolTypeInfo> networkProtocolTypeInfoList)
    {
        var routeTypeInfos = networkProtocolTypeInfoList.Where(d => d.RouteType.HasValue).ToList();
        var builder = new SourceCodeBuilder();
        // 添加文件头
        builder.AppendLine(GeneratorConstants.AutoGeneratedHeader);
        // 添加 using
        builder.AddUsings(
            "System",
            "System.Collections.Generic",
            "Fantasy.Assembly",
            "Fantasy.DataStructure.Collection",
            "System.Runtime.CompilerServices"
        );
        builder.AppendLine();
        // 开始命名空间（固定使用 Fantasy.Generated）
        builder.BeginNamespace("Fantasy.Generated");
        // 开始类定义（实现 INetworkProtocolOpCodeResolver 接口）
        builder.AddXmlComment($"Auto-generated OpCodeRegistrar class for {assemblyName}");
        builder.BeginClass("OpCodeRegistrar", "internal sealed", "IOpCodeRegistrar");
        // 开始定义GetOpCodeCount方法
        builder.AddXmlComment("GetOpCodeCount");
        builder.BeginMethod("public int GetOpCodeCount()");
        builder.AppendLine(RoslynExtensions.IsFantasyAssembly(assemblyName)
            ? "return 0;"
            : $"return {networkProtocolTypeInfoList.Count};");
        builder.EndMethod();
        // 开始定义GetCustomRouteTypeCount方法
        builder.AddXmlComment("GetCustomRouteTypeCount");
        builder.BeginMethod("public int GetCustomRouteTypeCount()");
        builder.AppendLine(RoslynExtensions.IsFantasyAssembly(assemblyName)
            ? "return 0;"
            : $"return {routeTypeInfos.Count};");
        builder.EndMethod();
        // 开始定义OpCodeTypeDictionary方法
        builder.AddXmlComment("OpCodeTypeDictionary");
        builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        builder.BeginMethod("public void FillOpCodeType(uint[] opCodes, Type[] types)");
        
        try
        {
            if (!RoslynExtensions.IsFantasyAssembly(assemblyName) && networkProtocolTypeInfoList.Any())
            {
                for (var i = 0; i < networkProtocolTypeInfoList.Count; i++)
                {
                    var (fullName, opCode, _, _) = networkProtocolTypeInfoList[i];
                    builder.AppendLine($"opCodes[{i}] = {opCode};");
                    builder.AppendLine($"types[{i}] = typeof({fullName});");
                }
            }
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            throw;
        }
        
        builder.EndMethod();
        // 开始定义FillCustomRouteType方法
        builder.AddXmlComment("FillCustomRouteType");
        builder.BeginMethod("public void FillCustomRouteType(uint[] opCodes, int[] routeTypes)");
        
        if (!RoslynExtensions.IsFantasyAssembly(assemblyName) && routeTypeInfos.Any())
        {
            for (var i = 0; i < routeTypeInfos.Count; i++)
            {
                var (_, opCode, _, routeType) = routeTypeInfos[i];
                builder.AppendLine($"opCodes[{i}] = {opCode};");
                builder.AppendLine($"routeTypes[{i}] = {routeType};");
            }
        }
        
        builder.EndMethod();
        builder.AppendLine();
        // 结束类和命名空间
        builder.EndClass();
        builder.EndNamespace();
        // 输出源代码
        context.AddSource("OpCodeRegistrar.g.cs", builder.ToString());
    }

    private static void GenerateResponseTypeRegistrarCode(
        SourceProductionContext context,
        string assemblyName,
        List<NetworkProtocolTypeInfo> networkProtocolTypeInfoList)
    {
        var requestList = networkProtocolTypeInfoList.Where(d => d.ResponseType != null).ToList();
        var builder = new SourceCodeBuilder();
        // 添加文件头
        builder.AppendLine(GeneratorConstants.AutoGeneratedHeader);
        // 添加 using
        builder.AddUsings(
            "System",
            "System.Collections.Generic",
            "Fantasy.Assembly",
            "Fantasy.DataStructure.Collection",
            "System.Runtime.CompilerServices"
        );
        builder.AppendLine();
        // 开始命名空间（固定使用 Fantasy.Generated）
        builder.BeginNamespace("Fantasy.Generated");
        // 开始类定义（实现 IEventSystemRegistrar 接口）
        builder.AddXmlComment($"Auto-generated ResponseTypeRegistrar class for {assemblyName}");
        builder.BeginClass("ResponseTypeRegistrar", "internal sealed", "IResponseTypeRegistrar");
        builder.AddXmlComment($"GetRequestCount");
        builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        builder.BeginMethod("public int GetRequestCount()");
        builder.AppendLine(RoslynExtensions.IsFantasyAssembly(assemblyName)
            ? "return 0;"
            : $"return {requestList.Count};");
        builder.EndMethod();
        // 开始定义GetOpCodeType方法
        builder.AddXmlComment($"FillResponseType");
        builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        builder.BeginMethod("public void FillResponseType(uint[] opCodes, Type[] types)");
        try
        {
            if (!RoslynExtensions.IsFantasyAssembly(assemblyName) && requestList.Any())
            {
                for (var i = 0; i < requestList.Count; i++)
                {
                    var (_, opCode, responseType, _) = requestList[i];
                    builder.AppendLine($"opCodes[{i}] = {opCode};");
                    builder.AppendLine($"types[{i}] = typeof({responseType});");
                }
            }
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            throw;
        }
        builder.EndMethod();
        builder.AppendLine();
        // 结束类和命名空间
        builder.EndClass();
        builder.EndNamespace();
        // 输出源代码
        context.AddSource("ResponseTypeRegistrar.g.cs", builder.ToString());
    }

    #endregion
    
    private static NetworkProtocolTypeInfo? GetNetworkProtocolInfo(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;

        if (symbol == null || !symbol.IsInstantiable())
        {
            return null;
        }

        var baseType = symbol.BaseType;

        if (baseType == null)
        {
            return null;
        }

        if (baseType.ToDisplayString() != "Fantasy.Network.Interface.AMessage")
        {
            return null;
        }

        // 获取 OpCode 方法的值
        uint? opCodeValue = null;
        var opCodeMethod = symbol.GetMembers("OpCode").OfType<IMethodSymbol>().FirstOrDefault();
        var opCodeSyntax = opCodeMethod?.DeclaringSyntaxReferences.FirstOrDefault()?.GetSyntax() as MethodDeclarationSyntax;

        if (opCodeSyntax?.Body != null)
        {
            var returnStatement = opCodeSyntax.Body.DescendantNodes()
                .OfType<ReturnStatementSyntax>()
                .FirstOrDefault();

            if (returnStatement?.Expression != null)
            {
                var constantValue = context.SemanticModel.GetConstantValue(returnStatement.Expression);
                if (constantValue.HasValue && constantValue.Value is uint uintValue)
                {
                    opCodeValue = uintValue;
                }
            }
        }

        if (!opCodeValue.HasValue)
        {
            return null;
        }

        // 获取 ResponseType 属性及其类型
        string? responseTypeName = null;
        var responseTypeProperty = symbol.GetMembers("ResponseType").OfType<IPropertySymbol>().FirstOrDefault();
        if (responseTypeProperty != null)
        {
            // 获取 ResponseType 属性的类型（例如 G2C_TestResponse）
            responseTypeName = responseTypeProperty.Type.GetFullName();
        }
        
        // 获取 RouteType 属性的值
        int? routeTypeValue = null;
        var routeTypeProperty = symbol.GetMembers("RouteType").OfType<IPropertySymbol>().FirstOrDefault();
        var routeTypeSyntax = routeTypeProperty?.DeclaringSyntaxReferences.FirstOrDefault()?.GetSyntax() as PropertyDeclarationSyntax;
        if (routeTypeSyntax?.ExpressionBody != null)
        {
            var constantValue = context.SemanticModel.GetConstantValue(routeTypeSyntax.ExpressionBody.Expression);
            if (constantValue.HasValue && constantValue.Value is int intValue)
            {
                routeTypeValue = intValue;
            }
        }

        return new NetworkProtocolTypeInfo(
            symbol.GetFullName(),
            opCodeValue.Value,
            responseTypeName,
            routeTypeValue
        );
    }

    private static bool IsNetworkProtocolClass(SyntaxNode node)
    {
        if (node is not ClassDeclarationSyntax classDecl)
        {
            return false;
        }

        if (classDecl.BaseList == null)
        {
            return false;
        }
        
        foreach (var baseTypeSyntax in classDecl.BaseList.Types)
        {
            if (baseTypeSyntax.Type.ToString().Contains("AMessage"))
            {
                return true;
            }
        }
        
        return false;
    }

    private sealed record NetworkProtocolTypeInfo(
        string FullName,
        uint OpCode,
        string? ResponseType,
        int? RouteType);
}