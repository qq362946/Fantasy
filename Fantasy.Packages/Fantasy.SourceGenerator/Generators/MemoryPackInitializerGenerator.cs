using Fantasy.SourceGenerator.Common;
using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Linq;

namespace Fantasy.SourceGenerator.Generators
{
    /// <summary>
    /// MemoryPack 初始化器生成器
    /// 为每个程序集生成 MemoryPack formatter 注册代码
    /// 解决 AOT 环境下静态构造函数可能不执行的问题
    /// </summary>
    [Generator]
    public class MemoryPackInitializerGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // 收集所有标记了 [MemoryPackable] 特性的类型
            // 使用 CreateSyntaxProvider 以兼容 Roslyn 4.0.1
            var memoryPackableTypesProvider = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: (node, _) => node is Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax ||
                                            node is Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax,
                    transform: (ctx, _) =>
                    {
                        var symbol = ctx.SemanticModel.GetDeclaredSymbol(ctx.Node) as INamedTypeSymbol;
                        if (symbol == null) return null;

                        // 检查是否有 MemoryPackable 特性
                        var hasMemoryPackableAttr = symbol.GetAttributes().Any(attr =>
                        {
                            var attrClass = attr.AttributeClass;
                            return attrClass != null &&
                                   attrClass.Name == "MemoryPackableAttribute" &&
                                   attrClass.ContainingNamespace?.ToDisplayString() == "MemoryPack";
                        });

                        return hasMemoryPackableAttr ? symbol : null;
                    })
                .Where(symbol => symbol != null)
                .Collect();

            // 组合编译信息和收集的类型
            var compilationAndTypes = context.CompilationProvider
                .Combine(memoryPackableTypesProvider);

            // 注册源代码输出
            context.RegisterSourceOutput(compilationAndTypes, (spc, source) =>
            {
                var (compilation, types) = source;

                if (CompilationHelper.IsSourceGeneratorDisabled(compilation))
                {
                    return;
                }

                if (!CompilationHelper.HasFantasyDefine(compilation))
                {
                    // 不是 Fantasy 框架项目，跳过代码生成
                    return;
                }

                // // 如果没有 MemoryPackable 类型，跳过生成
                // if (types.Length == 0)
                // {
                //     return;
                // }

                GenerateMemoryPackInitializer(spc, compilation, types!);
            });
        }

        private static void GenerateMemoryPackInitializer(
            SourceProductionContext context,
            Compilation compilation,
            IEnumerable<INamedTypeSymbol> memoryPackableTypes)
        {
            var targetPlatform = CompilationHelper.GetTargetPlatform(compilation);
            var className = compilation.GetAssemblyName("MemoryPackInitializer", out var assemblyName, out _);
            var builder = new SourceCodeBuilder();

            // 添加文件头
            builder.AppendLine(GeneratorConstants.AutoGeneratedHeader);

            // 添加 using
            switch (targetPlatform)
            {
                case 1: // Server (.NET)
                {
                    builder.AddUsings(
                        "System",
                        "System.Runtime.CompilerServices"
                    );
                    break;
                }
                case 2: // Unity
                {
                    builder.AddUsings(
                        "System",
                        "UnityEngine"
                    );
                    break;
                }
                case 3: // Unity 但没有使用Unity相关的程序集
                {
                    builder.AddUsings(
                        "System",
                        "System.Runtime.CompilerServices"
                    );
                    break;
                }
            }

            builder.AppendLine();

            // 开始命名空间
            builder.BeginDefaultNamespace();

            // 添加类注释
            builder.AddXmlComment($"Auto-generated MemoryPack initializer for {assemblyName}");
            builder.AddXmlComment("Ensures all MemoryPack formatters are registered before first use in AOT environment");
            builder.AddXmlComment("This solves the issue where static constructors may not execute in Native AOT");

            // 开始类定义
            builder.BeginClass(className, "public static");

            // 添加字段
            builder.AppendLine("private static bool _initialized;");
            builder.AppendLine();

            // 生成初始化方法
            GenerateInitializeMethod(builder, memoryPackableTypes, targetPlatform);

            // 结束类
            builder.EndClass();
            builder.AppendLine();

            // 结束命名空间
            builder.EndNamespace();

            // 输出源代码
            context.AddSource($"{className}.g.cs", builder.ToString());
        }

        private static void GenerateInitializeMethod(
            SourceCodeBuilder builder,
            IEnumerable<INamedTypeSymbol> memoryPackableTypes,
            int targetPlatform)
        {
            // 根据平台生成不同的初始化方法签名
            switch (targetPlatform)
            {
                case 1: // Server (.NET)
                {
                    builder.AddXmlComment("Module initializer - automatically called when assembly is loaded");
                    builder.AddXmlComment("Triggers static constructors of all MemoryPackable types to register formatters");
                    builder.AppendLine("[ModuleInitializer]");
                    builder.BeginMethod("public static void Initialize()");
                    break;
                }
                case 2: // Unity
                {
                    builder.AddXmlComment("Unity runtime initializer - automatically called when entering play mode or on app start");
                    builder.AddXmlComment("Triggers static constructors of all MemoryPackable types to register formatters");
                    builder.AppendLine("[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]");
                    builder.BeginMethod("public static void Initialize()");
                    break;
                }
                case 3: // Unity 但没有使用Unity相关的程序集
                {
                    builder.AddXmlComment("Module initializer - automatically called when assembly is loaded");
                    builder.AddXmlComment("Triggers static constructors of all MemoryPackable types to register formatters");
                    builder.BeginMethod("public static void Initialize()");
                    break;
                }
            }

            // 防止重复初始化
            builder.AppendLine("if (_initialized)");
            builder.OpenBrace();
            builder.AppendLine("return;");
            builder.CloseBrace();
            builder.AppendLine();
            builder.AppendLine("_initialized = true;");
            builder.AppendLine();

            // 添加注释
            builder.AddComment("Trigger static constructors of all MemoryPackable types");
            builder.AddComment("This ensures both MemoryPack registration and user-defined StaticConstructor() are executed");
            builder.AddComment("RuntimeHelpers.RunClassConstructor is supported in Native AOT");
            builder.AppendLine();

            // 生成 try-catch 块来保护初始化过程
            builder.AppendLine("try");
            builder.OpenBrace();

            // 为每个 MemoryPackable 类型触发静态构造函数
            foreach (var type in memoryPackableTypes)
            {
                var fullTypeName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                // 使用 RuntimeHelpers.RunClassConstructor 触发静态构造函数
                // 这会执行 MemoryPack 的注册代码 + 用户自定义的 StaticConstructor()
                builder.AddComment($"Trigger static constructor for {type.Name}");
                builder.AppendLine($"RuntimeHelpers.RunClassConstructor(typeof({fullTypeName}).TypeHandle);");
            }

            builder.CloseBrace();
            builder.AppendLine("catch (Exception ex)");
            builder.OpenBrace();
            builder.AddComment("Log error but don't throw - avoid breaking app startup");
            builder.AppendLine("#if FANTASY_NET");
            builder.AppendLine("Fantasy.Log.Error($\"Failed to initialize MemoryPack formatters: {ex}\");");
            builder.AppendLine("#elif UNITY_EDITOR");
            builder.AppendLine("UnityEngine.Debug.LogError($\"Failed to initialize MemoryPack formatters: {ex}\");");
            builder.AppendLine("#else");
            builder.AppendLine("Console.WriteLine($\"Failed to initialize MemoryPack formatters: {ex}\");");
            builder.AppendLine("#endif");
            builder.CloseBrace();

            // 结束方法
            builder.EndMethod();
        }
    }
}
