using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using CSharpExtensions = Microsoft.CodeAnalysis.CSharp.CSharpExtensions;

namespace LightProto.Generator;

[Generator(LanguageNames.CSharp)]
public class LightProtoGenerator : IIncrementalGenerator
{
    const string NewLine = "\r\n";
    const string ProtoContractAttributeFullName = "LightProto.ProtoContractAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var symbols = context.SyntaxProvider.ForAttributeWithMetadataName(
            ProtoContractAttributeFullName,
            predicate: (node, _) =>
                node
                    is ClassDeclarationSyntax
                        or StructDeclarationSyntax
                        or InterfaceDeclarationSyntax
                        or RecordDeclarationSyntax,
            transform: (ctx, _) => ctx.TargetSymbol
        );

        var typesAndCompilation = symbols.Combine(context.CompilationProvider);

        context.RegisterSourceOutput(
            typesAndCompilation,
            (spc, pair) =>
            {
                var (type, compilation) = pair;
                try
                {
                    var contract = GetProtoContract(compilation, type);
                    if (contract is null)
                    {
                        return;
                    }

                    // Generate the basic IMessage implementation
                    var sourceCode = GenerateBasicProtobufMessage(contract);
                    var fileName = $"{type}.g.cs";
                    spc.AddSource(fileName, SourceText.From(sourceCode, Encoding.UTF8));
                }
                catch (LightProtoGeneratorException e)
                {
                    spc.ReportDiagnostic(
                        Diagnostic.Create(
                            new DiagnosticDescriptor(
                                e.Id,
                                e.Title,
                                e.Message,
                                e.Category,
                                e.Severity,
                                isEnabledByDefault: true
                            ),
                            e.Location ?? Location.None,
                            additionalLocations: e.AdditionalLocations
                        )
                    );
                }
                catch (Exception e)
                {
                    spc.ReportDiagnostic(
                        Diagnostic.Create(
                            new DiagnosticDescriptor(
                                "LIGHT_PROTO_000",
                                "Unknown Exception",
                                e.ToString().Replace(NewLine, " "),
                                "Unknown",
                                DiagnosticSeverity.Error,
                                isEnabledByDefault: true
                            ),
                            Location.None
                        )
                    );
                }
            }
        );
    }

    public string Invoke(bool prediction, Func<string> ifTrue, Func<string> ifFalse)
    {
        return prediction ? ifTrue() : ifFalse();
    }

    public string Invoke(Func<bool> prediction, Func<string> ifTrue, Func<string> ifFalse)
    {
        return prediction() ? ifTrue() : ifFalse();
    }

    private string GenerateBasicProtobufMessage(ProtoContract contract)
    {
        var targetType = contract.Type;
        var compilation = contract.Compilation;
        var namespaceDeclare = targetType.ContainingNamespace.IsGlobalNamespace
            ? ""
            : $"namespace {targetType.ContainingNamespace.ToDisplayString()} {{";
        var className = targetType.Name;

        var typeDeclarationString = targetType.IsValueType
            ? targetType.IsRecord
                ? "partial record struct"
                : "partial struct"
            : targetType.IsRecord
                ? "partial record"
                : targetType.TypeKind == TypeKind.Interface
                    ? "public sealed partial class"
                    : "partial class";
        var proxyFor = contract.ProxyFor;
        bool skipConstructor = contract.SkipConstructor;
        var implicitFields = contract.ImplicitFields;

        var sourceBuilder = new StringBuilder();

        sourceBuilder.AppendLine(
            $$"""
              // <auto-generated>
              //     Generated by {{nameof(
                  LightProtoGenerator
              )}} at {{DateTime.Now:yyyy-MM-dd HH:mm:ss}}
              // </auto-generated>

              #pragma warning disable 1591, 0612, 3021, 8981, CS9035, CS0109, CS8669, CS1570, CS0219, RS0016, RS0041
              using System;
              using System.Linq;
              using LightProto;
              {{namespaceDeclare}}
              """
        );

        var protoMembers = contract.Members;

        string showFiledNumber = string.Empty;
        if (implicitFields is not ImplicitFields.None)
        {
            showFiledNumber = string.Join(
                NewLine,
                protoMembers
                    .OrderBy(o => o.FieldNumber)
                    .Select(o => $"/// {o.Name} FieldNumber: {o.FieldNumber} <br/>")
            );
        }

        string debuggerDisplay = string.Empty;
        if (targetType.TypeKind is not TypeKind.Interface)
        {
            debuggerDisplay =
                "[global::System.Diagnostics.DebuggerDisplayAttribute(\"{ToString(),nq}\")]";
        }

        string classBody;
        if (GetBaseProtoType(targetType) is not null || contract.DerivedTypeContracts.Any())
        {
            var derivedTypes = contract.DerivedTypeContracts.ToList();
            INamedTypeSymbol? baseType = GetBaseProtoType(targetType);

            string baseParserTypeName =
                baseType?.TypeKind is TypeKind.Interface
                    ? baseType.ToDisplayString() + "ProtoParser"
                    : baseType?.ToDisplayString() ?? targetType.ToDisplayString();

            classBody = (
                $$"""
                  /// <summary>
                  /// Auto-generated IMessage implementation for {{targetType.ToDisplayString()}}<br/>
                  {{showFiledNumber}}
                  /// </summary>
                  {{debuggerDisplay}}
                  {{typeDeclarationString}} {{className}}{{(targetType.TypeKind is TypeKind.Interface?"ProtoParser":"")}} :{{(proxyFor is null ?$"IProtoParser<{className}>":$"IProtoParser<{proxyFor.ToDisplayString()}>")}}
                  {
                      public static new IProtoReader<{{proxyFor?.ToDisplayString() ?? className}}> ProtoReader {get;} = new LightProtoReader();
                      {{
                          Invoke(baseType is null||targetType.TypeKind is TypeKind.Struct, // Structs do not support contravariance/covariance and cannot use the base class/interface's Writer, so a separate implementation is required
                              () => $"public static IProtoWriter<{proxyFor?.ToDisplayString() ?? className}> ProtoWriter {{get;}} = new LightProtoWriter();", 
                              () => $"public static new IProtoWriter<{proxyFor?.ToDisplayString()??className}> ProtoWriter => {baseParserTypeName}.ProtoWriter;")
                      }}
                      internal static new IProtoReader<MemberStruct> MemberStructReader {get; } = new MemberStructLightProtoReader();
                      internal static new IProtoWriter<MemberStruct> MemberStructWriter {get; } = new MemberStructLightProtoWriter();
                      
                      {{
                          Invoke(baseType is null, 
                              () => {
                                  return string.Join(NewLine+GetIntendedSpace(1), Gen());
                                  IEnumerable<string> Gen()
                                  {
                                      yield return $"internal sealed class LightProtoReader:IProtoReader<{proxyFor?.ToDisplayString() ?? className}>";
                                      yield return "{";
                                      yield return "    public bool IsMessage => true;";
                                      yield return "    public WireFormat.WireType WireType => WireFormat.WireType.LengthDelimited;";
                                      yield return $"    public {proxyFor?.ToDisplayString() ?? className} ParseFrom(ref ReaderContext input)=>MemberStructReader.ParseFrom(ref input).ToMessage();";
                                      yield return "}";
                                  }
                              }, 
                              () => {
                                  return string.Join(NewLine+GetIntendedSpace(1), Gen());
                                  IEnumerable<string> Gen()
                                  {
                                      yield return $"internal sealed new class LightProtoReader:IProtoReader<{proxyFor?.ToDisplayString() ?? className}>";
                                      yield return "{";
                                      yield return "    public bool IsMessage => true;";
                                      yield return "    public WireFormat.WireType WireType => WireFormat.WireType.LengthDelimited;";
                                      yield return $"    public {proxyFor?.ToDisplayString() ?? className} ParseFrom(ref ReaderContext input)=>({proxyFor?.ToDisplayString() ?? className}){baseParserTypeName}.ProtoReader.ParseFrom(ref input);";
                                      yield return "}";
                                  }
                              })
                      }}
                      
                      {{
                          Invoke(baseType is null, 
                              () => {
                                  return string.Join(NewLine+GetIntendedSpace(1), Gen());
                                  IEnumerable<string> Gen()
                                  {
                                      yield return $"internal sealed class LightProtoWriter:IProtoWriter<{proxyFor?.ToDisplayString() ?? className}>";
                                      yield return "{";
                                      yield return $"    public bool IsMessage => true;";
                                      yield return $"    public WireFormat.WireType WireType => WireFormat.WireType.LengthDelimited;";
                                      yield return $"    public void WriteTo(ref WriterContext output, {className} message) => MemberStructWriter.WriteTo(ref output, MemberStruct.FromMessage(message));";
                                      yield return $"    public int CalculateSize({className} message) => MemberStructWriter.CalculateSize(MemberStruct.FromMessage(message));";
                                      yield return "}";
                                  }
                              }, 
                              () => {
                                  if (targetType.TypeKind is TypeKind.Struct)
                                  {
                                      return string.Join(NewLine+GetIntendedSpace(1), Gen());
                                      IEnumerable<string> Gen()
                                      {
                                          yield return $"internal sealed class LightProtoWriter:IProtoWriter<{proxyFor?.ToDisplayString() ?? className}>";
                                          yield return "{";
                                          yield return $"    public bool IsMessage => true;";
                                          yield return $"    public WireFormat.WireType WireType => WireFormat.WireType.LengthDelimited;";
                                          yield return $"    public void WriteTo(ref WriterContext output, {className} message) => MemberStructWriter.WriteTo(ref output, MemberStruct.FromMessage(message));";
                                          yield return $"    public int CalculateSize({className} message) => MemberStructWriter.CalculateSize(MemberStruct.FromMessage(message));";
                                          yield return "}";
                                      }
                                  }
                                  else
                                  {
                                      return string.Empty;
                                  }
                              })
                      }}
                      
                      internal new struct MemberStruct
                      {
                          {{string.Join(NewLine + GetIntendedSpace(1),
                              protoMembers.Select(member => $"public {member.Type} {member.Name};"))
                          }}
                          {{string.Join(NewLine + GetIntendedSpace(1),
                              derivedTypes.Select(member => $"public {member.Contract.Type}.MemberStruct? {member.Contract.Type.Name}_MemberStruct;"))
                          }}
                          public static MemberStruct FromMessage({{className}} message)
                          {
                              var memberStruct = new MemberStruct
                              {
                                  {{string.Join("," + NewLine + GetIntendedSpace(3),
                                      protoMembers.Select(member => $"{member.Name}=message.{member.Name}"))
                                  }}
                              };
                              {{string.Join(NewLine + GetIntendedSpace(1),
                                  derivedTypes.Select((member,index) => {
                                      return $"if (message is {member.Contract.Type} derived{index}) {{ memberStruct.{member.Contract.Type.Name}_MemberStruct = {member.Contract.Type}.MemberStruct.FromMessage(derived{index}); }}";
                                  }))
                              }}
                              return memberStruct;
                          }
                          {{
                              Invoke(baseType is null,
                                  () => {
                                      return string.Join(NewLine+GetIntendedSpace(2), Gen());

                                      IEnumerable<string> Gen()
                                      {
                                          yield return $"public {className} ToMessage()";
                                          yield return "{";
                                          foreach (var member in derivedTypes)
                                          {
                                              yield return $"    if({member.Contract.Type.Name}_MemberStruct.HasValue) return {member.Contract.Type}.MemberStruct.ToMessage(this,{member.Contract.Type.Name}_MemberStruct.Value);";
                                          }
                                          
                                          if (targetType.TypeKind is TypeKind.Interface || targetType.IsAbstract)
                                          {
                                              yield return $"    throw new InvalidOperationException(\"Unknown sub type of {targetType} when Deserializing\");";
                                              yield return "}";
                                          }
                                          else
                                          {
                                              yield return $"    var parsed = new {className}()";
                                              yield return "    {";
                                              foreach (var member in protoMembers)
                                              {
                                                  yield return $"        {member.Name}={member.Name},";
                                              }
                                              yield return "    };";
                                              yield return "    return parsed;";
                                              yield return "}";
                                          }
                                      }
                                  }, 
                                  () => {
                                      return string.Join(NewLine+GetIntendedSpace(2), Gen());
                                      IEnumerable<string> Gen()
                                      {
                                          var rootBaseType = GetRootProtoBaseClass(baseType!);
                                          string rootBaseTypeMemberStructName = $"{rootBaseType}.MemberStruct";
                                          if (rootBaseType.TypeKind is TypeKind.Interface)
                                          {
                                               rootBaseTypeMemberStructName = $"{rootBaseType}ProtoParser.MemberStruct";
                                          }
                                          yield return $"public static {className} ToMessage(in {rootBaseTypeMemberStructName} rootMemberStruct,in MemberStruct memberStruct)";
                                          yield return "{";
                                          foreach (var member in derivedTypes)
                                          {
                                              yield return $"    if(memberStruct.{member.Contract.Type.Name}_MemberStruct.HasValue) return {member.Contract.Type}.MemberStruct.ToMessage(rootMemberStruct,memberStruct.{member.Contract.Type.Name}_MemberStruct.Value);";
                                          }
                                          yield return $"    var parsed = new {className}()";
                                          yield return "    {";
                                          foreach(var member in protoMembers)
                                          {
                                              yield return $"        {member.Name}=memberStruct.{member.Name},";
                                          }

                                          var currentBaseType = baseType;
                                          List<INamedTypeSymbol> derivedLevelTypes = new();
                                          while (true)
                                          {
                                              if (currentBaseType is null || IsProtoBufMessage(currentBaseType)==false)
                                              {
                                                  break;
                                              }
                                              derivedLevelTypes.Add(currentBaseType);
                                              currentBaseType = currentBaseType.BaseType;
                                          }
                                              
                                          derivedLevelTypes.Reverse();
                                          var memberStructName = "rootMemberStruct";
                                          for (var index = 0; index < derivedLevelTypes.Count; index++)
                                          {
                                              var derivedType = derivedLevelTypes[index];
                                              
                                              if (index > 0)
                                              {
                                                  memberStructName += $".{derivedType.Name}_MemberStruct.Value";
                                              }
                                                  
                                              var baseProtoMembers = GetProtoContract(compilation, derivedType)!.Members;
                                              foreach(var member in baseProtoMembers)
                                              {
                                                  yield return $"        {member.Name}={memberStructName}.{member.Name},";
                                              }
                                          }

                                          yield return "    };";
                                          yield return "    return parsed;";
                                          yield return "}";
                                      }
                                  })
                          }}
                      }
                      internal sealed new class MemberStructLightProtoWriter:IProtoWriter<MemberStruct>
                      {
                          public bool IsMessage => true;
                          public WireFormat.WireType WireType => WireFormat.WireType.LengthDelimited;
                          {{string.Join(NewLine + GetIntendedSpace(2),
                              protoMembers.SelectMany(member =>
                              {
                                  if (TryGetInternalTypeName(member.Type, member.DataFormat,member.StringIntern, out _)==false)
                                  {
                                      return GetProtoParserMember(compilation, member, "Writer", targetType);
                                  }
                                  else
                                  {
                                      return [];
                                  }
                              }))
                          }}
                          public void WriteTo(ref WriterContext output, MemberStruct message)
                          {
                              {{string.Join(NewLine + GetIntendedSpace(3),
                                  protoMembers.SelectMany(member => {
                                      return Gen();
                                      IEnumerable<string> Gen()
                                      {
                                          var checkIfNotEmpty = GetCheckIfNotEmpty(member,"message");

                                          yield return $"if({checkIfNotEmpty})";
                                          yield return $"{{";
                                          if (IsCollectionType(compilation, member.Type) || IsDictionaryType(compilation, member.Type))
                                          {
                                              yield return $"    {member.Name}_ProtoWriter.WriteTo(ref output, message.{member.Name});";
                                          }
                                          else if (TryGetInternalTypeName(member.Type, member.DataFormat,member.StringIntern, out var name))
                                          {
                                              yield return $"    output.WriteTag({member.RawTag}); ";
                                              yield return $"    output.Write{name}(message.{member.Name});";
                                          }
                                          else
                                          {
                                              yield return $"    output.WriteTag({member.RawTag}); ";
                                              yield return $"    {member.Name}_ProtoWriter.WriteMessageTo(ref output, message.{member.Name});";
                                          }   
                                          yield return $"}}";
                                      }
                                  }))
                              }}
                              {{string.Join(NewLine + GetIntendedSpace(3),
                                  derivedTypes.Select(member => $"if(message.{member.Contract.Type.Name}_MemberStruct.HasValue) {{ output.WriteTag({member.RawTag}); {member.Contract.Type}.MemberStructWriter.WriteMessageTo(ref output, message.{member.Contract.Type.Name}_MemberStruct.Value); }}"))
                              }}
                          }
                          
                          public int CalculateSize(MemberStruct message) {
                              int size=0;
                              {{string.Join(NewLine + GetIntendedSpace(3),
                                  protoMembers.SelectMany(member => {
                                      return Gen();

                                      IEnumerable<string> Gen()
                                      {
                                          var tagSize = member.RawTagSize;
                                          var checkIfNotEmpty = GetCheckIfNotEmpty(member,"message");

                                          if (IsCollectionType(compilation, member.Type) || IsDictionaryType(compilation, member.Type))
                                          {
                                              yield return $"if(message.{member.Name}!=null)";
                                              yield return $"    size += {member.Name}_ProtoWriter.CalculateSize(message.{member.Name}); ";
                                          }
                                          else if (TryGetInternalTypeName(member.Type, member.DataFormat,member.StringIntern, out var name))
                                          {
                                              yield return $"if({checkIfNotEmpty})";
                                              yield return $"    size += {tagSize} + CodedOutputStream.Compute{name}Size(message.{member.Name});";
                                          }
                                          else
                                          {
                                              yield return $"if({checkIfNotEmpty})";
                                              yield return $"    size += {tagSize} + {member.Name}_ProtoWriter.CalculateMessageSize(message.{member.Name});";
                                          }
                                      }
                                  }))
                              }}
                              
                              {{string.Join(NewLine + GetIntendedSpace(3),
                                  derivedTypes.Select(member => $"if(message.{member.Contract.Type.Name}_MemberStruct.HasValue) {{ size+={ProtoMember.GetRawTagSize(member.RawTag)}+{member.Contract.Type}.MemberStructWriter.CalculateMessageSize(message.{member.Contract.Type.Name}_MemberStruct.Value); }}"))
                              }}
                              return size;
                          }
                      }
                      
                      internal sealed new class MemberStructLightProtoReader:IProtoReader<MemberStruct>
                      {
                          public bool IsMessage => true;
                          public WireFormat.WireType WireType => WireFormat.WireType.LengthDelimited;
                          {{string.Join(NewLine + GetIntendedSpace(2),
                              protoMembers.SelectMany(member => {
                                  if (TryGetInternalTypeName(member.Type, member.DataFormat,member.StringIntern, out _)==false)
                                  {
                                      return GetProtoParserMember(compilation, member, "Reader", targetType);
                                  }
                                  else
                                  {
                                      return [];
                                  }
                              }))
                          }}
                          public MemberStruct ParseFrom(ref ReaderContext input)
                          {
                              {{string.Join(NewLine + GetIntendedSpace(3),
                                  protoMembers.Select(member => $"{member.Type} _{member.Name} = {member.Initializer};"))
                              }}
                              {{string.Join(NewLine + GetIntendedSpace(3),
                                  derivedTypes.Select(member => $"{member.Contract.Type}.MemberStruct? _{member.Contract.Type.Name}_memberStruct = null;"))
                              }}
                              uint tag;
                              while ((tag = input.ReadTag()) != 0) 
                              {
                                  if ((tag & 7) == 4) {
                                    break;
                                  }
                                  switch(tag) 
                                  {
                                      default: 
                                          input.SkipLastField();
                                          break;
                                      {{string.Join(NewLine + GetIntendedSpace(5), protoMembers.SelectMany(member =>
                                          {
                                              return Gen();

                                              IEnumerable<string> Gen()
                                              {
                                                  yield return $"case {member.RawTag}:";
                                                  if (IsCollectionType(compilation, member.Type))
                                                  {
                                                      var elementType = GetElementType(compilation, member.Type);
                                                      var tag2 = ProtoMember.GetRawTag(member.FieldNumber, ProtoMember.GetPbWireType(compilation, elementType, member.DataFormat));
                                                      if (tag2 != member.RawTag)
                                                      {
                                                          yield return $"case {tag2}:";
                                                      }
                                                  }

                                                  yield return $"{{";
                                                  if (TryGetInternalTypeName(member.Type, member.DataFormat,member.StringIntern, out var name))
                                                  {
                                                      yield return $"    _{member.Name} = input.Read{name}();";
                                                  }
                                                  else if (IsCollectionType(compilation, member.Type)||IsDictionaryType(compilation, member.Type))
                                                  {
                                                      yield return $"    _{member.Name} = {member.Name}_ProtoReader.ParseFrom(ref input);";
                                                  }
                                                  else
                                                  {
                                                      yield return $"    _{member.Name} = {member.Name}_ProtoReader.ParseMessageFrom(ref input);";
                                                  }
                                                  yield return $"    break;";
                                                  yield return $"}}";
                                              }
                                          }))
                                      }}
                                      {{string.Join(NewLine + GetIntendedSpace(3),
                                          derivedTypes.Select(member => $"case {member.RawTag}: _{member.Contract.Type.Name}_memberStruct = {member.Contract.Type}.MemberStructReader.ParseMessageFrom(ref input); break;"))
                                      }}
                                  }
                              }
                              var parsed = new MemberStruct()
                              {
                                  {{string.Join(NewLine + GetIntendedSpace(4),
                                      protoMembers.Select(member => {
                                          if (member.IsReadOnly && (IsCollectionType(compilation, member.Type)||IsDictionaryType(compilation, member.Type)))
                                          {
                                              return $"// {member.Name} is readonly";
                                          }
                                          else
                                          {
                                              return $"{member.Name} = _{member.Name},";
                                          }
                                      }))
                                  }}
                                 {{string.Join(NewLine + GetIntendedSpace(4),
                                     derivedTypes.Select(member => $"{member.Contract.Type.Name}_MemberStruct = _{member.Contract.Type.Name}_memberStruct,"))
                                 }}
                              };
                              {{string.Join(NewLine + GetIntendedSpace(3),
                                  protoMembers.SelectMany(member => {
                                      return Gen();
                                      IEnumerable<string> Gen()
                                      {   
                                          if (member.IsReadOnly && (IsCollectionType(compilation, member.Type)||IsDictionaryType(compilation, member.Type)))
                                          {
                                              yield return $"if(parsed.{member.Name}!=null) {{";
                                              yield return $"    parsed.{member.Name}.Clear();";
                                              yield return $"    if(_{member.Name}!=null) {{";
                                              if(IsStackType(member.Type))
                                                  yield return $"        foreach(var v in _{member.Name}.Reverse()) {{";
                                              else 
                                                  yield return $"        foreach(var v in _{member.Name}) {{";
                                              if(IsStackType(member.Type))
                                                  yield return $"            parsed.{member.Name}.Push(v);";
                                              else if(IsQueueType(member.Type))
                                                  yield return $"            parsed.{member.Name}.Enqueue(v);";
                                              else if(IsDictionaryType(compilation, member.Type))
                                                  yield return $"            parsed.{member.Name}[v.Key]=v.Value;";
                                              else 
                                                  yield return $"            parsed.{member.Name}.Add(v);";
                                              yield return $"        }}";
                                              yield return $"    }}";
                                              yield return $"}}";
                                          }
                                      }
                                  }).Where(x=>string.IsNullOrWhiteSpace(x)==false))
                              }}
                              return parsed;
                          }
                      }
                  }
                  """
            );
        }
        else
        {
            if (targetType.TypeKind == TypeKind.Interface)
            {
                throw LightProtoGeneratorException.Interface_Must_Have_ProtoInclude(
                    contract.TypeDeclaration.GetLocation()
                );
            }

            classBody = (
                $$"""
                  /// <summary>
                  /// Auto-generated IMessage implementation for {{targetType.ToDisplayString()}}<br/>
                  {{showFiledNumber}}
                  /// </summary>
                  {{debuggerDisplay}}
                  {{typeDeclarationString}} {{className}} :{{(proxyFor is null ?$"IProtoParser<{className}>":$"IProtoParser<{proxyFor.ToDisplayString()}>")}}
                  {
                      public static IProtoReader<{{proxyFor?.ToDisplayString()??className}}> ProtoReader {get; } = new LightProtoReader();
                      public static IProtoWriter<{{proxyFor?.ToDisplayString()??className}}> ProtoWriter {get; } = new LightProtoWriter();

                      internal sealed class LightProtoWriter:IProtoWriter<{{proxyFor?.ToDisplayString()??className}}>
                      {
                          public bool IsMessage => true;
                          public WireFormat.WireType WireType => WireFormat.WireType.LengthDelimited;
                          {{string.Join(NewLine + GetIntendedSpace(2),
                              protoMembers.SelectMany(member =>
                              {
                                  if (TryGetInternalTypeName(member.Type, member.DataFormat,member.StringIntern, out _)==false)
                                  {
                                      return GetProtoParserMember(compilation, member, "Writer", targetType);
                                  }
                                  else
                                  {
                                      return [];
                                  }
                              }))
                          }}
                          public void WriteTo(ref WriterContext output, {{proxyFor?.ToDisplayString()??className}} value)
                          {
                              {{className}} message = value;
                              {{string.Join(NewLine + GetIntendedSpace(3),
                                  protoMembers.SelectMany(member => {
                                      return Gen();

                                      IEnumerable<string> Gen()
                                      {
                                          var checkIfNotEmpty = GetCheckIfNotEmpty(member,"message");

                                          yield return $"if({checkIfNotEmpty})";
                                          yield return $"{{";
                                          if (IsCollectionType(compilation, member.Type) || IsDictionaryType(compilation, member.Type))
                                          {
                                              yield return $"    {member.Name}_ProtoWriter.WriteTo(ref output, message.{member.Name});";
                                          }
                                          else if (TryGetInternalTypeName(member.Type, member.DataFormat,member.StringIntern, out var name))
                                          {
                                              yield return $"    output.WriteTag({member.RawTag}); ";
                                              yield return $"    output.Write{name}(message.{member.Name});";
                                          }
                                          else
                                          {
                                              yield return $"    output.WriteTag({member.RawTag}); ";
                                              yield return $"    {member.Name}_ProtoWriter.WriteMessageTo(ref output, message.{member.Name});";
                                          }       
                                          yield return $"}}";
                                      }
                                  }))
                              }}
                          }
                          
                          public int CalculateSize({{proxyFor?.ToDisplayString()??className}} value) {
                              {{className}} message = value;
                              int size=0;
                              {{string.Join(NewLine + GetIntendedSpace(3),
                                  protoMembers.SelectMany(member => {
                                      return Gen();

                                      IEnumerable<string> Gen()
                                      {
                                          var tagSize = member.RawTagSize;
                                          var checkIfNotEmpty = GetCheckIfNotEmpty(member,"message");

                                          if (IsCollectionType(compilation, member.Type) || IsDictionaryType(compilation, member.Type))
                                          {
                                              yield return $"if(message.{member.Name}!=null)";
                                              yield return $"    size += {member.Name}_ProtoWriter.CalculateSize(message.{member.Name}); ";
                                          }
                                          else if (TryGetInternalTypeName(member.Type, member.DataFormat,member.StringIntern, out var name))
                                          {
                                              yield return $"if({checkIfNotEmpty})";
                                              yield return $"    size += {tagSize} + CodedOutputStream.Compute{name}Size(message.{member.Name});";
                                          }
                                          else
                                          {
                                              yield return $"if({checkIfNotEmpty})";
                                              yield return $"    size += {tagSize} + {member.Name}_ProtoWriter.CalculateMessageSize(message.{member.Name});";
                                          }
                                      }
                                  }))
                              }}
                              return size;
                          }
                      }
                      
                      internal sealed class LightProtoReader:IProtoReader<{{proxyFor?.ToDisplayString()??className}}>
                      {
                          public bool IsMessage => true;
                          public WireFormat.WireType WireType => WireFormat.WireType.LengthDelimited;
                          {{string.Join(NewLine + GetIntendedSpace(2),
                              protoMembers.SelectMany(member => {
                                  if (TryGetInternalTypeName(member.Type, member.DataFormat,member.StringIntern, out _)==false)
                                  {
                                      return GetProtoParserMember(compilation, member, "Reader", targetType);
                                  }
                                  else
                                  {
                                      return [];
                                  }
                              }))
                          }}
                          public {{proxyFor?.ToDisplayString()??className}} ParseFrom(ref ReaderContext input)
                          {
                              {{string.Join(NewLine + GetIntendedSpace(3),
                                  protoMembers.Select(member => $"{member.Type} _{member.Name} = default;"))
                              }}
                              {{string.Join(NewLine + GetIntendedSpace(3),
                                  protoMembers.Select(member => $"bool _{member.Name}HasValue = false;"))
                              }}
                              uint tag;
                              while ((tag = input.ReadTag()) != 0)
                              {
                                  if ((tag & 7) == 4) {
                                    break;
                                  }
                                  switch(tag) 
                                  {
                                      default:
                                          input.SkipLastField();
                                          break;
                                      {{string.Join(NewLine + GetIntendedSpace(5), protoMembers.SelectMany(member =>
                                          {
                                              return Gen();

                                              IEnumerable<string> Gen()
                                              {
                                                  yield return $"case {member.RawTag}:";
                                                  if (IsCollectionType(compilation, member.Type))
                                                  {
                                                      var elementType = GetElementType(compilation, member.Type);
                                                      var tag2 = ProtoMember.GetRawTag(member.FieldNumber, ProtoMember.GetPbWireType(compilation, elementType, member.DataFormat));
                                                      if (tag2 != member.RawTag)
                                                      {
                                                          yield return $"case {tag2}:";
                                                      }
                                                  }

                                                  if (TryGetInternalTypeName(member.Type, member.DataFormat,member.StringIntern, out var name))
                                                  {
                                                      yield return $"{{";
                                                      yield return $"    _{member.Name}HasValue = true;";
                                                      yield return $"    _{member.Name} = input.Read{name}();";
                                                      yield return $"    break;";
                                                      yield return $"}}";
                                                  }
                                                  else if (IsCollectionType(compilation, member.Type)||IsDictionaryType(compilation, member.Type))
                                                  {
                                                      yield return $"{{";
                                                      yield return $"    _{member.Name}HasValue = true;";
                                                      yield return $"    _{member.Name} = {member.Name}_ProtoReader.ParseFrom(ref input);";
                                                      yield return $"    break;";
                                                      yield return $"}}";
                                                  }
                                                  else
                                                  {
                                                      yield return $"{{";
                                                      yield return $"    _{member.Name}HasValue = true;";
                                                      yield return $"    _{member.Name} = {member.Name}_ProtoReader.ParseMessageFrom(ref input);";
                                                      yield return $"    break;";
                                                      yield return $"}}";
                                                  }
                                              }
                                          }))
                                      }}
                                  }
                              }
                              {{string.Join(NewLine + GetIntendedSpace(3),
                                  protoMembers.Where(member=>member.IsProtoMemberRequired)
                                      .SelectMany(member => {
                                      return Gen();
                                      IEnumerable<string> Gen()
                                      {
                                          yield return $"if(_{member.Name}HasValue==false)";
                                          yield return $"    throw new InvalidProtocolBufferException(\"ProtoMember:{contract.Type}.{member.Name} is required but not found when deserialization.\");";
                                      }
                                  }))
                              }}
                              {{
                                  string.Join(NewLine + GetIntendedSpace(3),skipConstructor
                                      ?GenSkipConstructor()
                                      :GenGeneralConstructor())
                              }}
                              {{string.Join(NewLine + GetIntendedSpace(3),
                                  protoMembers.SelectMany(member => {
                                      return Gen();
                                      IEnumerable<string> Gen()
                                      {
                                          if (member.IsReadOnly && (IsCollectionType(compilation, member.Type)||IsDictionaryType(compilation, member.Type)))
                                          {
                                              yield return $"if(parsed.{member.Name}!=null) {{";
                                              yield return $"    parsed.{member.Name}.Clear();";
                                              yield return $"    if(_{member.Name}!=null) {{";
                                              if(IsStackType(member.Type))
                                                  yield return $"        foreach(var v in _{member.Name}.Reverse()) {{";
                                              else 
                                                  yield return $"        foreach(var v in _{member.Name}) {{";
                                              if(IsStackType(member.Type))
                                                  yield return $"            parsed.{member.Name}.Push(v);";
                                              else if(IsQueueType(member.Type))
                                                  yield return $"            parsed.{member.Name}.Enqueue(v);";
                                              else if(IsDictionaryType(compilation, member.Type))
                                                  yield return $"            parsed.{member.Name}[v.Key]=v.Value;";
                                              else 
                                                  yield return $"            parsed.{member.Name}.Add(v);";
                                              yield return $"        }}";
                                              yield return $"    }}";
                                              yield return $"}}";
                                          }
                                      }
                                  }).Where(x=>string.IsNullOrWhiteSpace(x)==false))
                              }}
                              return parsed;
                          }
                      }
                  }
                  """
            );
            IEnumerable<string> GenSkipConstructor()
            {
                yield return $"var parsed = ({className})System.Runtime.CompilerServices.RuntimeHelpers.GetUninitializedObject(typeof({className}));";
                foreach (var member in protoMembers)
                {
                    if (
                        member.IsReadOnly
                        && (
                            IsCollectionType(compilation, member.Type)
                            || IsDictionaryType(compilation, member.Type)
                        )
                    )
                    {
                        throw LightProtoGeneratorException.ReadOnlyWhenSkipConstructor(
                            member.Name,
                            member.DeclarationSyntax.GetLocation()
                        );
                    }
                    else if (member.IsInitOnly)
                    {
                        throw LightProtoGeneratorException.InitOnlyWhenSkipConstructor(
                            member.Name,
                            member.DeclarationSyntax.GetLocation()
                        );
                    }
                    else
                    {
                        yield return $"parsed.{member.Name} = _{member.Name}HasValue ? _{member.Name} : {member.Initializer};";
                    }
                }
            }

            IEnumerable<string> GenGeneralConstructor()
            {
                yield return $"var parsed = new {className}()";
                yield return $"{{";

                foreach (var member in protoMembers)
                {
                    if (
                        member.IsReadOnly
                        && (
                            IsCollectionType(compilation, member.Type)
                            || IsDictionaryType(compilation, member.Type)
                        )
                    )
                    {
                        yield return $"    // {member.Name} is readonly";
                    }
                    else
                    {
                        yield return $"    {member.Name} = _{member.Name}HasValue ? _{member.Name} : {member.Initializer},";
                    }
                }

                yield return $"}};";
            }
        }
        var nestedClassStructure = GenerateNestedClassStructure(targetType, classBody);
        sourceBuilder.AppendLine(nestedClassStructure);
        if (targetType.ContainingNamespace.IsGlobalNamespace == false)
        {
            sourceBuilder.Append(@"}");
        }
        return sourceBuilder.ToString();
    }

    private INamedTypeSymbol GetRootProtoBaseClass(INamedTypeSymbol type)
    {
        if (type.BaseType is null)
        {
            return type;
        }

        if (type.AllInterfaces.FirstOrDefault(IsProtoBufMessage) is { } it)
        {
            return it;
        }

        if (IsProtoBufMessage(type.BaseType) == false)
        {
            return type;
        }

        return GetRootProtoBaseClass(type.BaseType);
    }

    private static string GenerateNestedClassStructure(
        INamedTypeSymbol targetType,
        string classMemberBody
    )
    {
        // Build the list of containing classes from outermost to innermost
        var containers = new List<INamedTypeSymbol>();
        var current = targetType.ContainingType;
        while (current is not null)
        {
            containers.Add(current);
            current = current.ContainingType;
        }

        // Reverse to get from outermost to innermost
        containers.Reverse();

        // Wrap in container classes
        var result = classMemberBody;
        for (int i = containers.Count - 1; i >= 0; i--)
        {
            var container = containers[i];
            var containerAccessibility =
                container.DeclaredAccessibility is Accessibility.Public ? "public" : "internal";
            var indent = new string(' ', (containers.Count - 1 - i) * 4);

            // Add indentation to current result
            var indentedResult = string.Join(
                "\n",
                result
                    .Split('\n')
                    .Select(line => string.IsNullOrWhiteSpace(line) ? line : "    " + line)
            );

            result = $$"""
                {{indent}}{{containerAccessibility}} partial class {{container.Name}}
                {{indent}}{
                {{indentedResult}}
                {{indent}}}
                """;
        }

        return result;
    }

    private bool TryGetInternalTypeName(
        ITypeSymbol memberType,
        DataFormat format,
        bool stringIntern,
        out string name
    )
    {
        name = memberType.SpecialType switch
        {
            SpecialType.System_Boolean => "Bool",
            SpecialType.System_Int32 => format == DataFormat.FixedSize ? "SFixed32"
            : format == DataFormat.ZigZag ? "SInt32"
            : "Int32",
            SpecialType.System_UInt32 => format == DataFormat.FixedSize ? "Fixed32" : "UInt32",
            SpecialType.System_Int64 => format == DataFormat.FixedSize ? "SFixed64"
            : format == DataFormat.ZigZag ? "SInt64"
            : "Int64",
            SpecialType.System_UInt64 => format == DataFormat.FixedSize ? "Fixed64" : "UInt64",
            SpecialType.System_Single => "Float",
            SpecialType.System_Double => "Double",
            SpecialType.System_String when stringIntern is false => "String",
            _ => "",
        };
        return string.IsNullOrWhiteSpace(name) == false;
    }

    private string GetCheckIfNotEmpty(ProtoMember member, string messageName)
    {
        if (member.IsProtoMemberRequired)
            return "true";

        if (member.Type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T)
        {
            return $"{messageName}.{member.Name}.HasValue";
        }

        if (member.Type.SpecialType == SpecialType.System_DateTime)
        {
            return "true";
        }

        if (
            member.CompatibilityLevel >= CompatibilityLevel.Level300
            && (IsGuidType(member.Type) || IsDecimalType(member.Type))
        )
        {
            return "true";
        }

        if (member.Type.IsValueType)
        {
            return $"{messageName}.{member.Name} != default";
        }

        var check = $"{messageName}.{member.Name} != null";

        if (HasCountProperty(member.Type))
        {
            return $"{check} && {messageName}.{member.Name}.Count > 0";
        }
        if (HasLengthProperty(member.Type))
        {
            return $"{check} && {messageName}.{member.Name}.Length > 0";
        }

        return check;
    }

    private bool IsDecimalType(ITypeSymbol memberType)
    {
        return memberType.OriginalDefinition.SpecialType == SpecialType.System_Decimal;
    }

    public static bool HasCountProperty(ITypeSymbol type)
    {
        return HasProperty(type, "Count", SpecialType.System_Int32);
    }

    public static bool HasLengthProperty(ITypeSymbol type)
    {
        if (type.TypeKind == TypeKind.Array)
        {
            return true;
        }

        return HasProperty(type, "Length", SpecialType.System_Int32);
    }

    public static bool HasProperty(ITypeSymbol type, string name, SpecialType specialType)
    {
        if (
            type.GetMembers()
                .OfType<IPropertySymbol>()
                .Any(o => o.Name == name && o.Type.SpecialType == specialType)
        )
        {
            return true;
        }

        if (type.TypeKind == TypeKind.Interface)
        {
            if (type.AllInterfaces.Any(x => HasProperty(x, name, specialType)))
            {
                return true;
            }
        }
        return false;
    }

    private IEnumerable<string> GetProtoParserMember(
        Compilation compilation,
        ProtoMember member,
        string readOrWriter,
        ITypeSymbol targetType
    )
    {
        var protoParser = GetProtoParser(
            compilation,
            member.Type,
            member.DataFormat,
            member.MapFormat,
            readOrWriter,
            member.RawTag,
            targetType,
            member.IsPacked,
            depth: 0,
            member.CompatibilityLevel,
            member.StringIntern,
            member
        );

        var memberType = member.Type.WithNullableAnnotation(NullableAnnotation.None);

        yield return $"private IProto{readOrWriter}<{memberType}> _{member.Name}_Proto{readOrWriter};";
        yield return $"internal IProto{readOrWriter}<{memberType}> {member.Name}_Proto{readOrWriter} {{ get => _{member.Name}_Proto{readOrWriter} ??= {protoParser};}}";
    }

    public uint GetFieldNumber(uint rawTag)
    {
        return rawTag >> 3;
    }

    private string GetProtoParser(
        Compilation compilation,
        ITypeSymbol memberType,
        DataFormat format,
        (DataFormat keyFormat, DataFormat valueFormat) mapFormat,
        string readerOrWriter,
        uint rawTag,
        ITypeSymbol targetType,
        bool isPacked,
        int depth,
        CompatibilityLevel compatibilityLevel,
        bool stringIntern,
        ProtoMember member
    )
    {
        depth++;
        if (SymbolEqualityComparer.IncludeNullability.Equals(targetType, memberType))
        {
            return "this";
        }
        var proxyType = GetProxyType(memberType);
        if (proxyType is not null)
        {
            return GetProtoParser(
                compilation,
                proxyType,
                format,
                mapFormat,
                readerOrWriter,
                rawTag,
                targetType,
                isPacked,
                depth,
                compatibilityLevel,
                stringIntern,
                member
            );
        }

        if (IsProtoBufMessage(memberType))
        {
            return $"{memberType.WithNullableAnnotation(NullableAnnotation.None)}.Proto{readerOrWriter}";
        }

        var fieldNumber = GetFieldNumber(rawTag);
        if (memberType is IArrayTypeSymbol arrayType)
        {
            if (rawTag == 0)
            {
                throw new Exception("rawTag==0");
            }

            var elementType = arrayType.ElementType;
            if (elementType.SpecialType == SpecialType.System_Byte)
            {
                return $"LightProto.Parser.ByteArrayProtoParser.Proto{readerOrWriter}";
            }

            if (isPacked == false)
            {
                rawTag = ProtoMember.GetRawTag(
                    fieldNumber,
                    ProtoMember.GetPbWireType(compilation, elementType, format)
                );
            }

            var elementWriter = GetProtoParser(
                compilation,
                elementType,
                format,
                mapFormat,
                readerOrWriter,
                0,
                targetType,
                isPacked,
                depth,
                compatibilityLevel,
                stringIntern,
                member
            );
            var fixedSize = GetFixedSize(elementType, format);
            return $"new LightProto.Parser.ArrayProto{readerOrWriter}<{elementType}>({elementWriter},{rawTag},{fixedSize})";
        }

        if (memberType is INamedTypeSymbol namedType)
        {
            var typeArguments = namedType.TypeArguments;

            if (typeArguments.Length == 0)
            {
                // member level specified parser type
                INamedTypeSymbol? parserType =
                    member
                        .AttributeData.FirstOrDefault(o =>
                            o.AttributeClass?.ToDisplayString() == "LightProto.ProtoMemberAttribute"
                        )
                        ?.NamedArguments.FirstOrDefault(o => o.Key == "ParserType")
                        .Value.Value as INamedTypeSymbol;
                if (parserType is null)
                {
                    // target type / assembly level specified parser type
                    parserType =
                        ResolveParserTypeFromAttribute(namedType, targetType.GetAttributes(), false)
                        ?? ResolveParserTypeFromAttribute(
                            namedType,
                            targetType.ContainingModule.GetAttributes(),
                            false
                        )
                        ?? ResolveParserTypeFromAttribute(
                            namedType,
                            targetType.ContainingAssembly.GetAttributes(),
                            true
                        );
                }

                if (parserType is null)
                {
                    // type level specified parser type
                    parserType =
                        namedType
                            .GetAttributes()
                            .FirstOrDefault(o =>
                                o.AttributeClass?.ToDisplayString()
                                == "LightProto.ProtoParserTypeAttribute"
                            )
                            ?.ConstructorArguments[0]
                            .Value as INamedTypeSymbol;
                }

                if (parserType is null)
                {
                    // use self implemented parser type
                    if (
                        namedType.AllInterfaces.Any(o =>
                            o.ToDisplayString() == $"LightProto.IProtoParser<{namedType}>"
                        )
                    )
                    {
                        parserType = namedType;
                    }
                }

                if (parserType is not null)
                {
                    return $"{parserType}.Proto{readerOrWriter}";
                }

                if (namedType.TypeKind == TypeKind.Enum)
                {
                    return $"LightProto.Parser.EnumProtoParser<{namedType}>.Proto{readerOrWriter}";
                }

                var name = namedType.SpecialType switch
                {
                    SpecialType.System_Int32 when format is DataFormat.ZigZag => "SInt32",
                    SpecialType.System_Int64 when format is DataFormat.ZigZag => "SInt64",
                    SpecialType.System_Int32 when format is DataFormat.FixedSize => "SFixed32",
                    SpecialType.System_Int64 when format is DataFormat.FixedSize => "SFixed64",
                    SpecialType.System_UInt32 when format is DataFormat.FixedSize => "Fixed32",
                    SpecialType.System_UInt64 when format is DataFormat.FixedSize => "Fixed64",
                    _ => namedType.Name,
                };
                if (compatibilityLevel >= CompatibilityLevel.Level240)
                {
                    if (
                        namedType.SpecialType is SpecialType.System_DateTime
                        || IsTimeSpanType(namedType)
                    )
                    {
                        name = $"{name}240";
                    }
                }

                if (compatibilityLevel >= CompatibilityLevel.Level300)
                {
                    if (
                        IsGuidType(namedType)
                        || namedType.SpecialType == SpecialType.System_Decimal
                    )
                    {
                        name = $"{name}300";
                    }
                }
                if (namedType.SpecialType == SpecialType.System_String && stringIntern)
                {
                    name = "InternedString";
                }

                return $"LightProto.Parser.{name}ProtoParser.Proto{readerOrWriter}";
            }

            if (typeArguments.Length == 1)
            {
                if (
                    namedType.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T
                    || namedType.OriginalDefinition.ToDisplayString() == "System.Lazy<T>"
                )
                {
                    var elementType = typeArguments[0];
                    var elementParser = GetProtoParser(
                        compilation,
                        elementType,
                        format,
                        mapFormat,
                        readerOrWriter,
                        rawTag,
                        targetType,
                        isPacked,
                        depth,
                        compatibilityLevel,
                        stringIntern,
                        member
                    );
                    return $"new LightProto.Parser.{memberType.Name}Proto{readerOrWriter}<{elementType}>({elementParser})";
                }
                else
                {
                    if (rawTag == 0)
                    {
                        throw new Exception("does not support collection of collection.");
                    }

                    var elementType = typeArguments[0];
                    if (elementType.SpecialType == SpecialType.System_Byte)
                    {
                        return $"LightProto.Parser.ByteListProtoParser.Proto{readerOrWriter}";
                    }
                    var elementParser = GetProtoParser(
                        compilation,
                        elementType,
                        format,
                        mapFormat,
                        readerOrWriter,
                        0,
                        targetType,
                        isPacked,
                        depth,
                        compatibilityLevel,
                        stringIntern,
                        member
                    );
                    var fixedSize = GetFixedSize(elementType, format);

                    if (isPacked == false)
                    {
                        rawTag = ProtoMember.GetRawTag(
                            fieldNumber,
                            ProtoMember.GetPbWireType(compilation, elementType, format)
                        );
                    }
                    if (namedType.TypeKind == TypeKind.Interface)
                    {
                        if (readerOrWriter == "Reader")
                        {
                            if (IsListType(compilation, namedType))
                            {
                                return $"new LightProto.Parser.ListProto{readerOrWriter}<{elementType}>({elementParser},{rawTag},{fixedSize})";
                            }

                            if (IsSetType(compilation, namedType))
                            {
                                return $"new LightProto.Parser.HashSetProto{readerOrWriter}<{elementType}>({elementParser},{rawTag},{fixedSize})";
                            }
                        }
                        else if (readerOrWriter == "Writer")
                        {
                            if (IsCollectionType(compilation, elementType, namedType))
                            {
                                var count = "Count()";
                                if (HasCountProperty(memberType))
                                {
                                    count = "Count";
                                }
                                if (HasLengthProperty(memberType))
                                {
                                    count = "Length";
                                }
                                return $"new LightProto.Parser.IEnumerableProto{readerOrWriter}<{memberType},{elementType}>({elementParser},{rawTag},static (d)=>d.{count},{fixedSize})";
                            }
                        }
                    }

                    if (
                        namedType.TypeKind == TypeKind.Class
                        || namedType.TypeKind == TypeKind.Struct
                    )
                    {
                        return $"new LightProto.Parser.{memberType.Name}Proto{readerOrWriter}<{elementType}>({elementParser},{rawTag},{fixedSize})";
                    }
                }
            }

            if (typeArguments.Length == 2)
            {
                if (rawTag == 0)
                {
                    throw new Exception("rawTag==0");
                }

                var keyType = typeArguments[0];
                var keyTag = ProtoMember.GetRawTag(
                    1,
                    ProtoMember.GetPbWireType(compilation, keyType, mapFormat.keyFormat)
                );
                var keyWriter = GetProtoParser(
                    compilation,
                    GetProxyType(keyType) ?? keyType,
                    mapFormat.keyFormat,
                    mapFormat,
                    readerOrWriter,
                    keyTag,
                    targetType,
                    isPacked: false,
                    depth: depth,
                    compatibilityLevel,
                    stringIntern,
                    member
                );
                var valueType = typeArguments[1];
                var valueTag = ProtoMember.GetRawTag(
                    2,
                    ProtoMember.GetPbWireType(compilation, valueType, mapFormat.valueFormat)
                );
                var valueWriter = GetProtoParser(
                    compilation,
                    GetProxyType(valueType) ?? valueType,
                    mapFormat.valueFormat,
                    mapFormat,
                    readerOrWriter,
                    valueTag,
                    targetType,
                    isPacked: false,
                    depth: depth,
                    compatibilityLevel,
                    stringIntern,
                    member
                );
                if (namedType.TypeKind == TypeKind.Interface)
                {
                    if (readerOrWriter == "Reader")
                    {
                        var mapType = compilation
                            .GetTypeByMetadataName("System.Collections.Generic.Dictionary`2")
                            ?.Construct(keyType, valueType)!;
                        var conversion = compilation.ClassifyConversion(mapType, namedType);
                        if (conversion.IsImplicit)
                        {
                            return $"new LightProto.Parser.DictionaryProto{readerOrWriter}<{keyType},{valueType}>({keyWriter},{valueWriter},{rawTag})";
                        }
                    }
                    else if (readerOrWriter == "Writer")
                    {
                        if (IsDictionaryType(compilation, keyType, valueType, namedType))
                        {
                            var count = "Count()";

                            if (HasCountProperty(memberType))
                            {
                                count = "Count";
                            }
                            return $"new LightProto.Parser.IEnumerableKeyValuePairProto{readerOrWriter}<{memberType},{keyType},{valueType}>({keyWriter},{valueWriter},{rawTag},static (d)=>d.{count})";
                        }
                    }
                }

                if (namedType.TypeKind == TypeKind.Class || namedType.TypeKind == TypeKind.Struct)
                {
                    return $"new LightProto.Parser.{memberType.Name}Proto{readerOrWriter}<{keyType},{valueType}>({keyWriter},{valueWriter},{rawTag})";
                }
            }
        }

        throw LightProtoGeneratorException.Member_Type_Not_Supported(member);
    }

    INamedTypeSymbol? ResolveParserTypeFromAttribute(
        INamedTypeSymbol memberType,
        ImmutableArray<AttributeData> attributes,
        bool isAssembly
    )
    {
        var mapAttributes = attributes
            .Where(o =>
                o.AttributeClass?.ToDisplayString() == "LightProto.ProtoParserTypeMapAttribute"
                && SymbolEqualityComparer.Default.Equals(
                    o.ConstructorArguments[0].Value as INamedTypeSymbol,
                    memberType
                )
            )
            .ToArray();
        if (mapAttributes.Length > 1)
        {
            throw LightProtoGeneratorException.Duplicate_ProtoParserTypeMapAttribute(
                memberType.ToDisplayString(),
                mapAttributes
                    .Select(x => x.ApplicationSyntaxReference?.GetSyntax().GetLocation())
                    .OfType<Location>()
                    .ToArray()
            );
        }

        var attribute = mapAttributes.FirstOrDefault();
        if (attribute is null)
            return null;

        var parser = (attribute.ConstructorArguments[1].Value as INamedTypeSymbol)!;

        var isProtoContract = parser
            .GetAttributes()
            .Any(o => o.AttributeClass?.ToDisplayString() == ProtoContractAttributeFullName);

        var memberTypeDisplayString = memberType
            .WithNullableAnnotation(NullableAnnotation.None)
            .ToDisplayString();
        // if parser does not contain static member named ProtoReader and is IProtoReader<T> or ProtoWriter and is IProtoWriter<T>, then error
        var hasProtoReader = parser
            .GetMembers()
            .OfType<IPropertySymbol>()
            .Any(o =>
                o.IsStatic
                && o.Name == "ProtoReader"
                && o.Type is INamedTypeSymbol returnType
                && (
                    returnType.AllInterfaces.Any(i =>
                        i.ToDisplayString() == $"LightProto.IProtoReader<{memberTypeDisplayString}>"
                    )
                    || returnType.ToDisplayString()
                        == $"LightProto.IProtoReader<{memberTypeDisplayString}>"
                )
            );
        if (isProtoContract == false && hasProtoReader == false)
        {
            throw LightProtoGeneratorException.ProtoParserTypeMustContainProtoReaderWriter(
                parser.ToDisplayString(),
                memberTypeDisplayString,
                attribute.ApplicationSyntaxReference?.GetSyntax().GetLocation()
            );
        }
        var hasProtoWriter = parser
            .GetMembers()
            .OfType<IPropertySymbol>()
            .Any(o =>
                o.IsStatic
                && o.Name == "ProtoWriter"
                && o.Type is INamedTypeSymbol returnType
                && (
                    returnType.AllInterfaces.Any(i =>
                        i.ToDisplayString() == $"LightProto.IProtoWriter<{memberTypeDisplayString}>"
                    )
                    || returnType.ToDisplayString()
                        == $"LightProto.IProtoWriter<{memberTypeDisplayString}>"
                )
            );

        if (isProtoContract == false && hasProtoWriter is false)
        {
            throw LightProtoGeneratorException.ProtoParserTypeMustContainProtoReaderWriter(
                parser.ToDisplayString(),
                memberTypeDisplayString,
                attribute.ApplicationSyntaxReference?.GetSyntax().GetLocation()
            );
        }

        if (isAssembly)
        {
            if (
                SymbolEqualityComparer.Default.Equals(
                    memberType.ContainingAssembly,
                    parser.ContainingAssembly
                )
            )
            {
                throw LightProtoGeneratorException.MessageTypeAndParserTypeCannotInSameAssemblyWhenUsingAssemblyLevelProtoParserMapAttribute(
                    memberType.ToDisplayString(),
                    parser.ToDisplayString(),
                    attribute.ApplicationSyntaxReference?.GetSyntax().GetLocation()
                );
            }
        }

        return parser;
    }

    private static bool IsCollectionType(Compilation compilation, ITypeSymbol type)
    {
        if (type is IArrayTypeSymbol arrayType)
        {
            return IsCollectionType(compilation, arrayType.ElementType, type);
        }

        if (type is not INamedTypeSymbol namedType)
            return false;

        if (namedType.TypeArguments.Length != 1)
            return false;

        if (namedType.OriginalDefinition.SpecialType is SpecialType.System_Nullable_T)
            return false;

        if (namedType.OriginalDefinition.ToDisplayString() == "System.Lazy<T>")
            return false;

        var elementType = namedType.TypeArguments[0];

        return IsCollectionType(compilation, elementType, namedType);
    }

    private static bool IsCollectionType(
        Compilation compilation,
        ITypeSymbol elementType,
        ITypeSymbol type
    )
    {
        if (elementType.SpecialType == SpecialType.System_Byte)
            return false;
        var baseCollectionType = compilation
            .GetTypeByMetadataName("System.Collections.Generic.IEnumerable`1")
            ?.Construct(elementType)!;
        var conversion = compilation.ClassifyConversion(type, baseCollectionType);
        return conversion.IsImplicit;
    }

    private static bool IsStackType(ITypeSymbol type)
    {
        if (type is not INamedTypeSymbol namedType)
            return false;

        var constructedFrom = namedType.OriginalDefinition.ToDisplayString();
        return constructedFrom
            is "System.Collections.Generic.Stack<T>"
                or "System.Collections.Concurrent.ConcurrentStack<T>";
    }

    private static bool IsQueueType(ITypeSymbol type)
    {
        if (type is not INamedTypeSymbol namedType)
            return false;

        var constructedFrom = namedType.OriginalDefinition.ToDisplayString();
        return constructedFrom
            is "System.Collections.Generic.Queue<T>"
                or "System.Collections.Concurrent.ConcurrentQueue<T>";
    }

    private static bool IsDictionaryType(
        Compilation compilation,
        ITypeSymbol keyType,
        ITypeSymbol valueType,
        INamedTypeSymbol namedType
    )
    {
        var keyValuePairType = compilation
            .GetTypeByMetadataName("System.Collections.Generic.KeyValuePair`2")
            ?.Construct(keyType, valueType)!;
        var baseDictionaryType = compilation
            .GetTypeByMetadataName("System.Collections.Generic.IEnumerable`1")
            ?.Construct(keyValuePairType)!;
        var conversion = compilation.ClassifyConversion(namedType, baseDictionaryType);
        return conversion.IsImplicit;
    }

    static bool IsDictionaryType(Compilation compilation, ITypeSymbol type)
    {
        if (type is not INamedTypeSymbol namedType)
            return false;
        if (namedType.TypeArguments.Length != 2)
            return false;
        var keyType = namedType.TypeArguments[0];
        var valueType = namedType.TypeArguments[1];

        return IsDictionaryType(compilation, keyType, valueType, namedType);
    }

    static ITypeSymbol GetElementType(Compilation compilation, ITypeSymbol collectionType)
    {
        if (IsArrayType(collectionType))
        {
            return ((IArrayTypeSymbol)collectionType).ElementType;
        }

        if (collectionType is INamedTypeSymbol { TypeArguments.Length: 1 } namedType)
        {
            return namedType.TypeArguments[0];
        }

        throw new ArgumentException(
            "Type is not an array, list, set, or concurrent collection type",
            nameof(collectionType)
        );
    }

    private int GetFixedSize(ITypeSymbol elementType, DataFormat dataFormat)
    {
        return elementType.SpecialType switch
        {
            SpecialType.System_Boolean => 1,
            SpecialType.System_Int32
            or SpecialType.System_UInt32 when dataFormat is DataFormat.FixedSize => 4,
            SpecialType.System_Int64
            or SpecialType.System_UInt64 when dataFormat is DataFormat.FixedSize => 8,
            SpecialType.System_Single => 4,
            SpecialType.System_Double => 8,
            _ => 0,
        };
    }

    private static bool HasProtoIncludeAttribute(
        INamedTypeSymbol baseType,
        INamedTypeSymbol derivedType
    )
    {
        return baseType
            .GetAttributes()
            .Any(attr =>
                attr.AttributeClass?.ToDisplayString() == "LightProto.ProtoIncludeAttribute"
                && SymbolEqualityComparer.Default.Equals(
                    attr.ConstructorArguments[1].Value as INamedTypeSymbol,
                    derivedType
                )
            );
    }

    private static INamedTypeSymbol? GetBaseProtoType(INamedTypeSymbol type)
    {
        if (
            type.AllInterfaces.FirstOrDefault(interf =>
                IsProtoBufMessage(interf) && HasProtoIncludeAttribute(interf, type)
            ) is
            { } it
        )
        {
            return it;
        }

        var baseType = type.BaseType;
        while (true)
        {
            if (baseType is null)
            {
                return null;
            }

            if (IsProtoBufMessage(baseType) && HasProtoIncludeAttribute(baseType, type))
            {
                return baseType;
            }

            baseType = baseType.BaseType;
        }
    }

    private static bool IsProtoBufMessage(ITypeSymbol? memberType)
    {
        if (memberType is null)
        {
            return false;
        }
        return memberType.TypeKind != TypeKind.Enum
                && memberType
                    .GetAttributes()
                    .Any(o => o.AttributeClass?.ToDisplayString() == ProtoContractAttributeFullName)
            || (
                memberType is INamedTypeSymbol namedType
                && namedType.AllInterfaces.Any(i =>
                    i.ToDisplayString().StartsWith("LightProto.IProtoParser<")
                )
            );
    }

    static bool IsArrayType(ITypeSymbol type)
    {
        return type.TypeKind == TypeKind.Array;
    }

    static bool IsListType(Compilation compilation, ITypeSymbol type)
    {
        if (type is not INamedTypeSymbol namedType)
            return false;

        var typeArguments = namedType.TypeArguments;
        if (typeArguments.Length != 1)
        {
            return false;
        }

        var elementType = typeArguments[0];

        var listType = compilation
            .GetTypeByMetadataName("System.Collections.Generic.List`1")
            ?.Construct(elementType)!;
        var conversion = CSharpExtensions.ClassifyConversion(compilation, listType, type);
        return conversion.IsImplicit;
    }

    static bool IsSetType(Compilation compilation, ITypeSymbol type)
    {
        if (type is not INamedTypeSymbol namedType)
            return false;

        var typeArguments = namedType.TypeArguments;
        if (typeArguments.Length != 1)
        {
            return false;
        }

        var elementType = typeArguments[0];

        var listType = compilation
            .GetTypeByMetadataName("System.Collections.Generic.HashSet`1")
            ?.Construct(elementType)!;
        var conversion = CSharpExtensions.ClassifyConversion(compilation, listType, type);
        return conversion.IsImplicit;
    }

    static INamedTypeSymbol ResolveConcreteTypeSymbol(
        Compilation compilation,
        INamedTypeSymbol type
    )
    {
        // 
        var constructedFrom = type.OriginalDefinition.ToDisplayString();

        return constructedFrom switch
        {
            "System.Collections.Generic.IList<T>"
            or "System.Collections.Generic.IReadOnlyList<T>"
            or "System.Collections.Generic.ICollection<T>"
            or "System.Collections.Generic.IReadOnlyCollection<T>" => compilation
                .GetTypeByMetadataName("System.Collections.Generic.List`1")
                ?.Construct(type.TypeArguments.ToArray()) ?? type,

            "System.Collections.Generic.IDictionary<TKey, TValue>"
            or "System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>" => compilation
                .GetTypeByMetadataName("System.Collections.Generic.Dictionary`2")
                ?.Construct(type.TypeArguments.ToArray()) ?? type,

            "System.Collections.Generic.ISet<T>" => compilation
                .GetTypeByMetadataName("System.Collections.Generic.HashSet`1")
                ?.Construct(type.TypeArguments.ToArray()) ?? type,

            _ => type, // 
        };
    }

    string GetIntendedSpace(int i)
    {
        return new string(' ', i * 4);
    }

    static bool IsGuidType(ITypeSymbol type)
    {
        var displayString = type.ToDisplayString();
        return displayString == "System.Guid" || displayString == "Guid";
    }

    static bool IsTimeSpanType(ITypeSymbol type)
    {
        var displayString = type.ToDisplayString();
        return displayString == "System.TimeSpan" || displayString == "TimeSpan";
    }

    static bool IsDateOnlyType(ITypeSymbol type)
    {
        var displayString = type.ToDisplayString();
        return displayString == "System.DateOnly" || displayString == "DateOnly";
    }

    static bool IsTimeOnlyType(ITypeSymbol type)
    {
        var displayString = type.ToDisplayString();
        return displayString == "System.TimeOnly" || displayString == "TimeOnly";
    }

    static bool IsRuneType(ITypeSymbol type)
    {
        var displayString = type.ToDisplayString();
        return displayString == "System.Text.Rune" || displayString == "Rune";
    }

    static bool IsStringBuilderType(ITypeSymbol type)
    {
        var displayString = type.ToDisplayString();
        return displayString == "System.Text.StringBuilder" || displayString == "StringBuilder";
    }

    private static bool IsHalfType(ITypeSymbol type)
    {
        var displayString = type.ToDisplayString();
        return displayString == "System.Half" || displayString == "Half";
    }

    private ITypeSymbol? GetProxyType(IEnumerable<AttributeData> attributeDatas)
    {
        if (
            attributeDatas.FirstOrDefault(o =>
                o.AttributeClass?.ToDisplayString().StartsWith("LightProto.ProtoProxyAttribute<")
                == true
            ) is
            { } proxyAttr2
        )
        {
            return proxyAttr2.AttributeClass!.TypeArguments[0];
        }

        return null;
    }

    private ITypeSymbol? GetProxyFor(ImmutableArray<AttributeData> attributeDatas)
    {
        if (
            attributeDatas.FirstOrDefault(o =>
                o.AttributeClass?.ToDisplayString()
                    .StartsWith("LightProto.ProtoSurrogateForAttribute<") == true
            ) is
            { } proxyAttr2
        )
        {
            return proxyAttr2.AttributeClass!.TypeArguments[0];
        }
        if (
            attributeDatas.FirstOrDefault(o =>
                o.AttributeClass?.ToDisplayString() == ("LightProto.ProtoSurrogateForAttribute")
            ) is
            { } proxyAttr
        )
        {
            return proxyAttr.ConstructorArguments[0].Value as ITypeSymbol;
        }

        return null;
    }

    private ITypeSymbol? GetProxyType(ITypeSymbol type)
    {
        return GetProxyType(type.GetAttributes());
    }

    class ProtoContract
    {
        public Compilation Compilation { get; set; } = null!;
        public INamedTypeSymbol Type { get; set; } = null!;
        public TypeDeclarationSyntax TypeDeclaration { get; set; } = null!;
        public List<ProtoMember> Members { get; set; } = new();
        public ImplicitFields ImplicitFields { get; set; }
        public uint ImplicitFirstTag { get; set; }
        public ImmutableArray<AttributeData> AttributeData { get; set; }
        public bool SkipConstructor { get; set; }
        public ITypeSymbol? ProxyFor { get; set; }

        //public ProtoContract? BaseTypeContract { get; set; }
        public List<(uint RawTag, ProtoContract Contract)> DerivedTypeContracts { get; set; } =
            new();
    }

    private ProtoContract? GetProtoContract(Compilation compilation, ISymbol? type)
    {
        if (type is not INamedTypeSymbol targetType)
        {
            return null;
        }
        // Look for ProtoContract attribute
        var protoContractAttr = targetType
            .GetAttributes()
            .FirstOrDefault(attr =>
                attr.AttributeClass?.ToDisplayString() == ProtoContractAttributeFullName
            );

        if (protoContractAttr is null)
            return null;

        ImplicitFields implicitFields = (ImplicitFields)(
            protoContractAttr
                .NamedArguments.FirstOrDefault(arg => arg.Key == "ImplicitFields")
                .Value.Value
            ?? ImplicitFields.None
        );

        uint implicitFirstTag = uint.TryParse(
            protoContractAttr
                .NamedArguments.FirstOrDefault(arg => arg.Key == "ImplicitFirstTag")
                .Value.Value?.ToString(),
            out var _implicitFirstTag
        )
            ? _implicitFirstTag
            : 1;

        var skipConstructor =
            protoContractAttr
                .NamedArguments.FirstOrDefault(arg => arg.Key == "SkipConstructor")
                .Value.Value?.ToString() == "True";
        var typeDeclaration = (
            targetType.DeclaringSyntaxReferences.FirstOrDefault()?.GetSyntax()
            as TypeDeclarationSyntax
        )!;

        var proxyFor = GetProxyFor(targetType.GetAttributes());

        var protoIncludeAttributes = targetType
            .GetAttributes()
            .Where(attr =>
                attr.AttributeClass?.ToDisplayString() == "LightProto.ProtoIncludeAttribute"
            )
            .ToList();
        var derivedTypeContracts = new List<(uint RawTag, ProtoContract Contract)>();
        foreach (var attribute in protoIncludeAttributes)
        {
            if (
                uint.TryParse(attribute.ConstructorArguments[0].Value?.ToString(), out var tag)
                == false
            )
            {
                throw LightProtoGeneratorException.ProtoInclude_Tag_Invalid(
                    attribute.ApplicationSyntaxReference?.GetSyntax().GetLocation()
                );
            }
            var rawTag = ProtoMember.GetRawTag(tag, ProtoMember.PbWireType.LengthDelimited);
            var derivedType = attribute.ConstructorArguments[1].Value as INamedTypeSymbol;
            if (derivedType is null)
            {
                throw LightProtoGeneratorException.ProtoInclude_Type_Invalid(
                    attribute.ApplicationSyntaxReference?.GetSyntax().GetLocation()
                );
            }

            if (targetType.TypeKind == TypeKind.Interface)
            {
                if (
                    derivedType.AllInterfaces.Any(it =>
                        SymbolEqualityComparer.Default.Equals(it, targetType)
                    ) == false
                )
                {
                    throw LightProtoGeneratorException.ProtoInclude_Type_Not_Inherit(
                        attribute,
                        derivedType,
                        targetType
                    );
                }
            }
            else
            {
                var checkType = derivedType;
                while (true)
                {
                    if (checkType is null)
                    {
                        throw LightProtoGeneratorException.ProtoInclude_Type_Not_Inherit(
                            attribute,
                            derivedType,
                            targetType
                        );
                    }

                    if (SymbolEqualityComparer.Default.Equals(checkType.BaseType, targetType))
                    {
                        break;
                    }

                    checkType = checkType.BaseType;
                }
            }

            var contract = GetProtoContract(compilation, derivedType);
            if (contract is null)
            {
                throw LightProtoGeneratorException.ProtoInclude_Type_Should_Be_ProtoContract(
                    derivedType.ToDisplayString(),
                    attribute.ApplicationSyntaxReference?.GetSyntax().GetLocation()
                );
            }
            derivedTypeContracts.Add((rawTag, contract));
        }

        if (derivedTypeContracts.Any() && proxyFor is not null)
        {
            throw LightProtoGeneratorException.ProtoSurrogateFor_With_ProtoInclude(
                typeDeclaration.GetLocation()
            );
        }
        if (
            derivedTypeContracts
                .GroupBy(o => o.Contract.Type, SymbolEqualityComparer.Default)
                .FirstOrDefault(x => x.Count() > 1) is
            { } grp
        )
        {
            throw LightProtoGeneratorException.ProtoInclude_Duplicate_Type(
                grp.Key!.ToDisplayString(),
                typeDeclaration.GetLocation()
            );
        }

        return new ProtoContract
        {
            Compilation = compilation,
            Type = targetType,
            TypeDeclaration = typeDeclaration,
            Members = GetProtoMembers(
                compilation,
                targetType,
                typeDeclaration,
                implicitFields,
                implicitFirstTag
            ),
            ImplicitFields = implicitFields,
            ImplicitFirstTag = implicitFirstTag,
            AttributeData = default,
            SkipConstructor = skipConstructor,
            ProxyFor = proxyFor,
            //BaseTypeContract = GetProtoContract(compilation, targetType.BaseType),
            DerivedTypeContracts = derivedTypeContracts,
        };
    }

    private List<ProtoMember> GetProtoMembers(
        Compilation compilation,
        INamedTypeSymbol targetType,
        TypeDeclarationSyntax typeDeclaration,
        ImplicitFields implicitFields,
        uint firstImplicitTag
    )
    {
        var members = new List<ProtoMember>();
        var semanticModel = compilation.GetSemanticModel(typeDeclaration.SyntaxTree);
        var emitter = new ExpressionEmitter(semanticModel);
        foreach (var member in targetType.GetMembers())
        {
            if (member.IsStatic)
            {
                continue;
            }

            if (member.IsImplicitlyDeclared)
            {
                continue;
            }

            uint tag;
            DataFormat dataFormat;
            bool isPacked;
            bool isProtoMemberRequired;
            AttributeData? protoMemberAttr = member
                .GetAttributes()
                .FirstOrDefault(attr =>
                    attr.AttributeClass?.ToDisplayString() == "LightProto.ProtoMemberAttribute"
                );
            if (protoMemberAttr is not null)
            {
                tag = (uint)protoMemberAttr.ConstructorArguments[0].Value!;

                dataFormat = Enum.TryParse<DataFormat>(
                    protoMemberAttr
                        .NamedArguments.FirstOrDefault(kv => kv.Key == "DataFormat")
                        .Value.Value?.ToString(),
                    out var _dataFormat
                )
                    ? _dataFormat
                    : DataFormat.Default;

                isPacked =
                    bool.TryParse(
                        protoMemberAttr
                            .NamedArguments.FirstOrDefault(kv => kv.Key == "IsPacked")
                            .Value.Value?.ToString(),
                        out var _isPacked
                    ) && _isPacked;

                isProtoMemberRequired =
                    bool.TryParse(
                        protoMemberAttr
                            .NamedArguments.FirstOrDefault(kv => kv.Key == "IsRequired")
                            .Value.Value?.ToString(),
                        out var _isProtoMemberRequired
                    ) && _isProtoMemberRequired;
            }
            else
            {
                if (implicitFields is ImplicitFields.None)
                {
                    continue;
                }

                if (
                    implicitFields is ImplicitFields.AllPublic
                    && member.DeclaredAccessibility is not Accessibility.Public
                )
                {
                    continue;
                }

                if (member is not IPropertySymbol and not IFieldSymbol)
                {
                    continue;
                }

                if (member is IPropertySymbol { IsReadOnly: true })
                {
                    continue;
                }

                if (member is IFieldSymbol { IsReadOnly: true } or IFieldSymbol { IsConst: true })
                {
                    continue;
                }
                if (
                    member
                        .GetAttributes()
                        .Any(o =>
                            o.AttributeClass?.ToDisplayString() == "LightProto.ProtoIgnoreAttribute"
                        )
                )
                {
                    continue;
                }

                tag = firstImplicitTag;
                firstImplicitTag++;
                dataFormat = DataFormat.Default;
                isPacked = false;
                isProtoMemberRequired = false;
            }

            string memberName;
            string? initializer;
            NullableAnnotation nullableAnnotation;
            ITypeSymbol memberType;
            bool isReadOnly;
            bool isRequired;
            bool isInitOnly;
            MemberDeclarationSyntax? memberDeclarationSyntax;
            if (member is IPropertySymbol property)
            {
                memberName = property.Name;
                var propertyDeclarationSyntax = property
                    .DeclaringSyntaxReferences.Select(x => x.GetSyntax())
                    .OfType<PropertyDeclarationSyntax>()
                    .FirstOrDefault();
                memberDeclarationSyntax = propertyDeclarationSyntax;
                var initializerSyntax = propertyDeclarationSyntax?.Initializer?.Value;
                initializer = initializerSyntax is null ? null : emitter.Emit(initializerSyntax);
                nullableAnnotation = property.NullableAnnotation;
                memberType = property.Type;
                isReadOnly = property.IsReadOnly;
                isRequired = property.IsRequired;
                isInitOnly = property.SetMethod?.IsInitOnly == true;
            }
            else if (member is IFieldSymbol field)
            {
                memberName = field.Name;

                var fieldDeclarationSyntax = field
                    .DeclaringSyntaxReferences.Select(x =>
                        x.GetSyntax() is VariableDeclaratorSyntax v
                        && v.Parent is VariableDeclarationSyntax vd
                        && vd.Parent is FieldDeclarationSyntax f
                            ? f
                            : null
                    )
                    .OfType<FieldDeclarationSyntax>()
                    .FirstOrDefault();

                memberDeclarationSyntax = fieldDeclarationSyntax;
                var initializerSyntax = fieldDeclarationSyntax
                    ?.Declaration.Variables.FirstOrDefault()
                    ?.Initializer?.Value;
                initializer = initializerSyntax is null ? null : emitter.Emit(initializerSyntax);
                nullableAnnotation = field.NullableAnnotation;
                memberType = field.Type;
                isReadOnly = field.IsReadOnly;
                isRequired = field.IsRequired;
                isInitOnly = false;
            }
            else
            {
                continue;
            }

            if (memberDeclarationSyntax is null)
            {
                throw LightProtoGeneratorException.Member_DeclarationSyntax_Not_Found(
                    $"{targetType.ToDisplayString()}.{member.Name}"
                );
            }

            if (initializer is null)
            {
                if (nullableAnnotation == NullableAnnotation.Annotated)
                {
                    initializer = "null";
                }
                else if (HasEmptyStaticField(memberType))
                {
                    initializer = $"{memberType}.Empty";
                }
                else if (
                    IsCollectionType(compilation, memberType)
                    || IsDictionaryType(compilation, memberType)
                )
                {
                    if (memberType is IArrayTypeSymbol arrayTypeSymbol)
                    {
                        initializer = $"Array.Empty<{arrayTypeSymbol.ElementType}>()";
                    }
                    else if (memberType.TypeKind == TypeKind.Interface || memberType.IsAbstract)
                    {
                        var concreteType = ResolveConcreteTypeSymbol(
                            compilation,
                            (memberType as INamedTypeSymbol)!
                        );
                        initializer = $"new {concreteType.ToDisplayString()}()";
                    }
                    else
                    {
                        initializer = "default";
                    }
                }
                else
                {
                    initializer = "default";
                }
            }

            bool HasEmptyStaticField(ITypeSymbol type)
            {
                return type.GetMembers()
                    .OfType<IFieldSymbol>()
                    .Any(o => o.IsStatic && o.Name == "Empty");
            }

            ITypeSymbol? ProxyType =
                GetProxyType(member.GetAttributes()) ?? GetProxyType(memberType);

            bool HasStringInternAttribute(IEnumerable<AttributeData> attributeDatas)
            {
                return attributeDatas.Any(attr =>
                    attr.AttributeClass?.ToDisplayString() == "LightProto.StringInternAttribute"
                );
            }

            bool stringIntern =
                HasStringInternAttribute(member.GetAttributes())
                || HasStringInternAttribute(targetType.GetAttributes())
                || HasStringInternAttribute(targetType.ContainingModule.GetAttributes())
                || HasStringInternAttribute(targetType.ContainingAssembly.GetAttributes());

            AttributeData? GetCompatibilityLevelAttribute(IEnumerable<AttributeData> attributeDatas)
            {
                return attributeDatas.FirstOrDefault(attr =>
                    attr.AttributeClass?.ToDisplayString()
                    == "LightProto.CompatibilityLevelAttribute"
                );
            }

            AttributeData? compatibilityLevelAttr =
                GetCompatibilityLevelAttribute(member.GetAttributes())
                ?? GetCompatibilityLevelAttribute(targetType.GetAttributes())
                ?? GetCompatibilityLevelAttribute(targetType.ContainingModule.GetAttributes())
                ?? GetCompatibilityLevelAttribute(targetType.ContainingAssembly.GetAttributes());

            CompatibilityLevel compatibilityLevel = Enum.TryParse<CompatibilityLevel>(
                compatibilityLevelAttr?.ConstructorArguments[0].Value?.ToString(),
                out var _compatibilityLevel
            )
                ? _compatibilityLevel
                : CompatibilityLevel.Level200;

            if (
#pragma warning disable CS0618 // Type or member is obsolete
                dataFormat is DataFormat.WellKnown
#pragma warning restore CS0618 // Type or member is obsolete
                && compatibilityLevel <= CompatibilityLevel.Level200
            )
            {
                compatibilityLevel = CompatibilityLevel.Level240;
            }
            AttributeData? protoMapAttr = member
                .GetAttributes()
                .FirstOrDefault(attr =>
                    attr.AttributeClass?.ToDisplayString() == "LightProto.ProtoMapAttribute"
                );

            var keyFormat = Enum.TryParse<DataFormat>(
                protoMapAttr
                    ?.NamedArguments.FirstOrDefault(kv => kv.Key == "KeyFormat")
                    .Value.Value?.ToString(),
                out var _keyFormat
            )
                ? _keyFormat
                : DataFormat.Default;

            var valueFormat = Enum.TryParse<DataFormat>(
                protoMapAttr
                    ?.NamedArguments.FirstOrDefault(kv => kv.Key == "ValueFormat")
                    .Value.Value?.ToString(),
                out var _valueFormat
            )
                ? _valueFormat
                : DataFormat.Default;

            if (members.Any(o => o.FieldNumber == tag))
            {
                throw LightProtoGeneratorException.Member_Tag_Duplicated(
                    member.Name,
                    tag,
                    memberDeclarationSyntax.GetLocation()
                );
            }

            members.Add(
                new ProtoMember
                {
                    Name = memberName,
                    Type = memberType,
                    FieldNumber = tag,
                    Compilation = compilation,
                    IsRequired = isRequired,
                    IsProtoMemberRequired = isProtoMemberRequired,
                    IsInitOnly = isInitOnly,
                    AttributeData = member.GetAttributes(),
                    DataFormat = dataFormat,
                    MapFormat = (keyFormat, valueFormat),
                    ProxyType = ProxyType,
                    Initializer = initializer,
                    IsPacked = isPacked,
                    CompatibilityLevel = compatibilityLevel,
                    IsReadOnly = isReadOnly,
                    StringIntern = stringIntern,
                    DeclarationSyntax = memberDeclarationSyntax,
                }
            );
        }

        return members.OrderBy(m => m.FieldNumber).ToList();
    }

    internal class ProtoMember
    {
        public enum PbWireType
        {
            Varint = 0, // int32, int64, bool, enum ,uint32, uint64
            Fixed64 = 1, // double, fixed64, sfixed64
            LengthDelimited = 2, // string, bytes, message, repeated packed
            Fixed32 = 5, // float, fixed32, sfixed32
        }

        public Compilation Compilation { get; set; } = null!;

        public ITypeSymbol? ProxyType { get; set; }
        public string Name { get; set; } = "";
        public ITypeSymbol Type { get; set; } = null!;
        public DataFormat DataFormat { get; set; }
        public (DataFormat keyFormat, DataFormat valueFormat) MapFormat { get; set; }
        public uint FieldNumber { get; set; }
        public bool IsRequired { get; set; }

        /// <summary>
        /// When deserializing, if the field is required and the type is a reference type or nullable value type,
        /// we need to check if the value is null and throw an exception if it is.
        /// This is to prevent null reference exceptions when accessing the field later.
        /// </summary>
        public bool IsProtoMemberRequired { get; set; }

        public bool IsInitOnly { get; set; }
        public string Initializer { get; set; } = "default";
        public bool StringIntern { get; set; }

        public ImmutableArray<AttributeData> AttributeData { get; set; } =
            ImmutableArray<AttributeData>.Empty;

        public PbWireType WireType => GetPbWireType(Compilation, Type, DataFormat);

        public static PbWireType GetPbWireType(
            Compilation compilation,
            ITypeSymbol Type,
            DataFormat DataFormat
        )
        {
            // Handle nullable value types by getting the underlying type
            if (
                Type is INamedTypeSymbol namedType
                && (
                    namedType.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T
                    || namedType.OriginalDefinition.ToDisplayString() == "System.Lazy<T>"
                )
            )
            {
                return GetPbWireType(compilation, namedType.TypeArguments[0], DataFormat);
            }

            // Handle arrays, lists and sets
            if (IsCollectionType(compilation, Type))
            {
                return PbWireType.LengthDelimited;
            }

            // Handle dictionaries
            if (IsDictionaryType(compilation, Type))
            {
                return PbWireType.LengthDelimited;
            }

            if (Type.TypeKind == TypeKind.Enum)
            {
                return PbWireType.Varint;
            }

            switch (Type.SpecialType)
            {
                case SpecialType.System_Boolean:
                case SpecialType.System_Int32:
                {
                    return DataFormat == DataFormat.FixedSize
                        ? PbWireType.Fixed32
                        : PbWireType.Varint;
                }
                case SpecialType.System_UInt32:
                {
                    return DataFormat == DataFormat.FixedSize
                        ? PbWireType.Fixed32
                        : PbWireType.Varint;
                }
                case SpecialType.System_Int64:
                {
                    return DataFormat == DataFormat.FixedSize
                        ? PbWireType.Fixed64
                        : PbWireType.Varint;
                }
                case SpecialType.System_UInt64:
                {
                    return DataFormat == DataFormat.FixedSize
                        ? PbWireType.Fixed64
                        : PbWireType.Varint;
                }
                case SpecialType.System_Enum:
                    return PbWireType.Varint;
                case SpecialType.System_Single:
                case SpecialType.None when IsHalfType(Type): // float16
                    return PbWireType.Fixed32;
                case SpecialType.System_Double:
                    return PbWireType.Fixed64;
                case SpecialType.None when IsDateOnlyType(Type): //int32
                    return PbWireType.Varint;
                case SpecialType.None when IsTimeOnlyType(Type): //int64
                    return PbWireType.Varint;
                case SpecialType.None when IsRuneType(Type): //uint32
                    return PbWireType.Varint;
                case SpecialType.System_String:
                case SpecialType.None when IsGuidType(Type):
                case SpecialType.None when IsStringBuilderType(Type):
                case SpecialType.None
                    when Type.TypeKind == TypeKind.Class
                        || Type.TypeKind == TypeKind.Interface
                        || Type.TypeKind == TypeKind.Array:
                    return PbWireType.LengthDelimited;
                default:
                    // Default to LengthDelimited for other complex types
                    return PbWireType.LengthDelimited;
            }
        }

        public uint RawTag => GetRawTag(FieldNumber, WireType);
        public int RawTagSize => GetRawTagSize(RawTag);
        public bool IsPacked { get; set; }
        public CompatibilityLevel CompatibilityLevel { get; set; }
        public bool IsReadOnly { get; set; }
        public MemberDeclarationSyntax DeclarationSyntax { get; set; } = null!;

        public static uint GetRawTag(uint fieldNumber, PbWireType WireType)
        {
            return (fieldNumber << 3) | (uint)WireType;
        }

        public static int GetRawTagSize(uint value)
        {
            if ((value & (0xffffffff << 7)) == 0)
            {
                return 1;
            }
            if ((value & (0xffffffff << 14)) == 0)
            {
                return 2;
            }
            if ((value & (0xffffffff << 21)) == 0)
            {
                return 3;
            }
            if ((value & (0xffffffff << 28)) == 0)
            {
                return 4;
            }
            return 5;
        }
    }

    internal class LightProtoGeneratorException(string message) : Exception(message)
    {
        public string Id { get; set; } = string.Empty;
        public string Title { get; set; } = string.Empty;
        public string Category { get; set; } = string.Empty;
        public DiagnosticSeverity Severity { get; set; }
        public Location? Location { get; set; }
        public IEnumerable<Location>? AdditionalLocations { get; set; }

        public static LightProtoGeneratorException InitOnlyWhenSkipConstructor(
            string memberName,
            Location? location
        )
        {
            return new LightProtoGeneratorException(
                "Member should not be initonly when SkipConstructor as we can't assign a value to it"
            )
            {
                Id = "LIGHT_PROTO_001",
                Title = $"{memberName} is InitOnly",
                Category = "Usage",
                Severity = DiagnosticSeverity.Error,
                Location = location,
            };
        }

        public static LightProtoGeneratorException ReadOnlyWhenSkipConstructor(
            string memberName,
            Location? location
        )
        {
            return new LightProtoGeneratorException(
                "Member should not be readonly when SkipConstructor as we can't assign a value to it"
            )
            {
                Id = "LIGHT_PROTO_002",
                Title = $"{memberName} is InitOnly",
                Category = "Usage",
                Severity = DiagnosticSeverity.Error,
                Location = location,
            };
        }

        public static LightProtoGeneratorException ProtoInclude_Type_Invalid(Location? location)
        {
            return new LightProtoGeneratorException("ProtoInclude attribute type is not valid")
            {
                Id = "LIGHT_PROTO_003",
                Title = $"ProtoInclude attribute type is not valid",
                Category = "Usage",
                Severity = DiagnosticSeverity.Error,
                Location = location,
            };
        }

        public static LightProtoGeneratorException Member_Type_Not_Supported(ProtoMember member)
        {
            return new LightProtoGeneratorException(
                $"Member:{member.Name} Type: {member.Type} is not supported"
            )
            {
                Id = "LIGHT_PROTO_004",
                Title = $"MemberType is not supported",
                Category = "Usage",
                Severity = DiagnosticSeverity.Error,
                Location = member.DeclarationSyntax.GetLocation(),
            };
        }

        public static LightProtoGeneratorException ProtoInclude_Tag_Invalid(Location? location)
        {
            return new LightProtoGeneratorException("ProtoInclude attribute tag is not valid")
            {
                Id = "LIGHT_PROTO_005",
                Title = $"ProtoInclude attribute tag is not valid",
                Category = "Usage",
                Severity = DiagnosticSeverity.Error,
                Location = location,
            };
        }

        public static LightProtoGeneratorException Member_Tag_Duplicated(
            string memberName,
            uint tag,
            Location? location
        )
        {
            return new LightProtoGeneratorException($"Member:{memberName} Tag:{tag} is duplicated")
            {
                Id = "LIGHT_PROTO_006",
                Title = "Tag is duplicated",
                Category = "Usage",
                Severity = DiagnosticSeverity.Error,
                Location = location,
            };
        }

        public static LightProtoGeneratorException Interface_Must_Have_ProtoInclude(
            Location? location
        )
        {
            return new LightProtoGeneratorException("Interface must have ProtoIncludeAttribute")
            {
                Id = "LIGHT_PROTO_007",
                Title = $"Interface must have ProtoIncludeAttribute",
                Category = "Usage",
                Severity = DiagnosticSeverity.Error,
                Location = location,
            };
        }

        public static LightProtoGeneratorException Member_DeclarationSyntax_Not_Found(
            string memberName
        )
        {
            return new LightProtoGeneratorException(
                $"can not find Member:{memberName} DelclarationSyntax"
            )
            {
                Id = "LIGHT_PROTO_008",
                Title = "DeclarationSyntaxnot found",
                Category = "Usage",
                Severity = DiagnosticSeverity.Warning,
                Location = null,
            };
        }

        public static LightProtoGeneratorException ProtoInclude_Type_Not_Inherit(
            AttributeData attribute,
            INamedTypeSymbol derivedType,
            INamedTypeSymbol targetType
        )
        {
            return new LightProtoGeneratorException(
                $"ProtoInclude attribute type {derivedType.ToDisplayString()} does not inherit from {targetType.ToDisplayString()}"
            )
            {
                Id = "LIGHT_PROTO_009",
                Title = $"ProtoInclude attribute type does not inherit from target type",
                Category = "Usage",
                Severity = DiagnosticSeverity.Error,
                Location = attribute.ApplicationSyntaxReference?.GetSyntax().GetLocation(),
            };
        }

        public static LightProtoGeneratorException ProtoInclude_Type_Should_Be_ProtoContract(
            string derivedTypeName,
            Location? location
        )
        {
            return new LightProtoGeneratorException(
                $"ProtoInclude attribute type {derivedTypeName} should mark as ProtoContract"
            )
            {
                Id = "LIGHT_PROTO_010",
                Title = $"ProtoInclude attribute type should mark as ProtoContract",
                Category = "Usage",
                Severity = DiagnosticSeverity.Error,
                Location = location,
            };
        }

        public static LightProtoGeneratorException ProtoSurrogateFor_With_ProtoInclude(
            Location? location
        )
        {
            return new LightProtoGeneratorException(
                "ProtoSurrogateForAttribute cannot be used with ProtoInclude attribute"
            )
            {
                Id = "LIGHT_PROTO_011",
                Title = $"ProtoSurrogateForAttribute cannot be used with ProtoInclude attribute",
                Category = "Usage",
                Severity = DiagnosticSeverity.Error,
                Location = location,
            };
        }

        public static Exception ProtoInclude_Duplicate_Type(string typeName, Location location)
        {
            return new LightProtoGeneratorException(
                $"ProtoInclude attribute type {typeName} is duplicated"
            )
            {
                Id = "LIGHT_PROTO_012",
                Title = $"ProtoInclude attribute type is duplicated",
                Category = "Usage",
                Severity = DiagnosticSeverity.Error,
                Location = location,
            };
        }

        public static Exception Duplicate_ProtoParserTypeMapAttribute(
            string typeString,
            Location[] locations
        )
        {
            return new LightProtoGeneratorException(
                $"Duplicate ProtoParserTypeMapAttribute for type {typeString}"
            )
            {
                Id = "LIGHT_PROTO_013",
                Title = $"Duplicate ProtoParserTypeMapAttribute",
                Category = "Usage",
                Severity = DiagnosticSeverity.Error,
                Location = locations[0],
                AdditionalLocations = locations.Skip(1),
            };
        }

        public static Exception ProtoParserTypeMustContainProtoReaderWriter(
            string parserType,
            string messageType,
            Location? getLocation
        )
        {
            return new LightProtoGeneratorException(
                $"Proto parser type {parserType} must contain static IProtoReader<{messageType}> ProtoReader Property and static IProtoWriter<{messageType}> ProtoWriter Property"
            )
            {
                Id = "LIGHT_PROTO_014",
                Title =
                    $"Proto parser type must contain static ProtoReader or ProtoWriter Property",
                Category = "Usage",
                Severity = DiagnosticSeverity.Error,
                Location = getLocation,
            };
        }

        public static Exception MessageTypeAndParserTypeCannotInSameAssemblyWhenUsingAssemblyLevelProtoParserMapAttribute(
            string messageType,
            string parserType,
            Location? location
        )
        {
            return new LightProtoGeneratorException(
                $"message type({messageType}) and parser type({parserType}) cannot be in the same assembly when using assembly level ProtoParserMapAttribute. Consider using LightProto.ProtoParserType(Type parserType) on message type instead."
            )
            {
                Id = "LIGHT_PROTO_015",
                Title =
                    $"message type({messageType}) and parser type({parserType}) cannot be in the same assembly when using assembly level ProtoParserMapAttribute.",
                Category = "Usage",
                Severity = DiagnosticSeverity.Error,
                Location = location,
            };
        }
    }
}
