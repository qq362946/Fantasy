using Fantasy.SourceGenerator.Common;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Fantasy.SourceGenerator.Generators
{
    [Generator]
    public sealed class PoolCreatorGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var poolTypes = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (node, _) => IsPoolClass(node),
                    transform: static (ctx, _) => GetPoolTypeInfo(ctx))
                .Where(static info => info != null)
                .Collect();
            
            var compilationAndTypes = context.CompilationProvider.Combine(poolTypes);
            
            context.RegisterSourceOutput(compilationAndTypes, static (spc, source) =>
            {
                if (CompilationHelper.IsSourceGeneratorDisabled(source.Left))
                {
                    return;
                }

                if (!CompilationHelper.HasFantasyDefine(source.Left))
                {
                    return;
                }

                if (source.Left.GetTypeByMetadataName("Fantasy.Pool.IPool") == null)
                {
                    return;
                }

                GeneratePoolCreators(spc, source.Left, source.Right!);
            });
        }

        private static bool IsPoolClass(SyntaxNode node)
        {
            return node is ClassDeclarationSyntax classDecl && classDecl.Modifiers.All(m => m.Text != "abstract");
        }

        private static string? GetPoolTypeInfo(GeneratorSyntaxContext context)
        {
            var classDeclaration = (ClassDeclarationSyntax)context.Node;
            var symbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

            if (symbol == null || symbol.IsAbstract || symbol.DeclaredAccessibility != Accessibility.Public)
            {
                return null;
            }

            if (symbol.IsGenericType)
            {
                return null;
            }

            var hasParameterlessConstructor = symbol.Constructors.Any(c =>
                c.Parameters.Length == 0 && (c.DeclaredAccessibility == Accessibility.Public ||
                                             c.DeclaredAccessibility == Accessibility.Internal));

            if (!hasParameterlessConstructor)
            {
                return null;
            }

            var implementsIPool = symbol.AllInterfaces.Any(i =>
                i.Name == "IPool" && i.ContainingNamespace.ToString() == "Fantasy.Pool");

            if (!implementsIPool)
            {
                return null;
            }
            
            return symbol.GetFullName();
        }

        private static void GeneratePoolCreators(
            SourceProductionContext context,
            Compilation compilation,
            IEnumerable<string> poolTypes)
        {
            var validTypes = poolTypes.ToList();
            var builder = new SourceCodeBuilder();
            var markerClassName = compilation.GetAssemblyName("PoolCreatorGeneratorRegistrar", out var assemblyName, out _);
            
            builder.AppendLine(GeneratorConstants.AutoGeneratedHeader);
            
            builder.AddUsings(
                "System",
                "System.Collections.Generic",
                "Fantasy.Pool",
                "Fantasy.Network.Interface",
                "Fantasy.Serialize"
            );
            builder.AppendLine();
            builder.BeginNamespace("Fantasy.Generated");
            builder.AddXmlComment($"Auto-generated PoolCreatorGenerator class for {assemblyName}");
            builder.BeginClass(markerClassName, "internal sealed","global::Fantasy.Assembly.IPoolCreatorGenerator");
            // 开始定义RuntimeTypeHandles方法
            builder.AddXmlComment("TypeHashCodes");
            builder.BeginMethod("public global::System.RuntimeTypeHandle[] RuntimeTypeHandles()");
            
            if (validTypes.Any())
            {
                builder.AppendLine($"var runtimeTypeHandles = new global::System.RuntimeTypeHandle[{validTypes.Count}];");
                for (var i = 0; i < validTypes.Count; i++)
                {
                    builder.AppendLine($"runtimeTypeHandles[{i}] = typeof({validTypes[i]}).TypeHandle;");
                }
                builder.AppendLine("return runtimeTypeHandles;");
            }
            else
            {
                builder.AppendLine("return Array.Empty<global::System.RuntimeTypeHandle>();");
            }
            
            builder.EndMethod();
            // 开始定义TypeHashCodes方法
            builder.AddXmlComment("Generators");
            builder.BeginMethod("public Func<global::Fantasy.Pool.IPool>[] Generators()");
            
            if (validTypes.Any())
            {
                builder.AppendLine($"var generators = new Func<global::Fantasy.Pool.IPool>[{validTypes.Count}];");
                for (var i = 0; i < validTypes.Count; i++)
                {
                    builder.AppendLine($"generators[{i}] = () => new {validTypes[i]}();");
                }
                builder.AppendLine("return generators;");
            }
            else
            {
                builder.AppendLine("return Array.Empty<Func<global::Fantasy.Pool.IPool>>();");
            }
            
            builder.EndMethod();
            builder.EndClass();
            builder.EndNamespace();
            context.AddSource($"{markerClassName}.g.cs", builder.ToString());
        }
    }
}
